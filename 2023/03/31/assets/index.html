<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JUC | PC</title><meta name="author" content="pengchang"><meta name="copyright" content="pengchang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="1. JUC概述及回顾 1.1. JUC是什么？ 在 Java 5.0 提供了 java.util.concurrent(简称JUC)包，在此包中增加了在并发编程中很常用的工具类。此包包括了几个小的、已标准化的可扩展框架，并提供一些功能实用的类，没有这些类，一些功能会很难实现或实现起来冗长乏味。 参照JDK文档：  1.2. 进程和线程 进程：进程是一个具有一定独立功能的程序关于某个数据集合的一次">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC">
<meta property="og:url" content="http://example.com/2023/03/31/assets/index.html">
<meta property="og:site_name" content="PC">
<meta property="og:description" content="1. JUC概述及回顾 1.1. JUC是什么？ 在 Java 5.0 提供了 java.util.concurrent(简称JUC)包，在此包中增加了在并发编程中很常用的工具类。此包包括了几个小的、已标准化的可扩展框架，并提供一些功能实用的类，没有这些类，一些功能会很难实现或实现起来冗长乏味。 参照JDK文档：  1.2. 进程和线程 进程：进程是一个具有一定独立功能的程序关于某个数据集合的一次">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/5-%E8%AF%B7%E6%B1%82%E5%BA%94%E7%AD%94.png">
<meta property="article:published_time" content="2023-03-30T16:00:00.000Z">
<meta property="article:modified_time" content="2023-09-01T13:53:55.329Z">
<meta property="article:author" content="pengchang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/5-%E8%AF%B7%E6%B1%82%E5%BA%94%E7%AD%94.png"><link rel="shortcut icon" href="/img/1.png"><link rel="canonical" href="http://example.com/2023/03/31/assets/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JUC',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-01 21:53:55'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-clock/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2592/202208241424400.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/5-%E8%AF%B7%E6%B1%82%E5%BA%94%E7%AD%94.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">PC</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JUC</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-30T16:00:00.000Z" title="发表于 2023-03-31 00:00:00">2023-03-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-01T13:53:55.329Z" title="更新于 2023-09-01 21:53:55">2023-09-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JUC"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>1. JUC概述及回顾</h1>
<h2 id="1-1-JUC是什么？">1.1. JUC是什么？</h2>
<p>在 Java 5.0 提供了 <code>java.util.concurrent</code>(简称JUC)包，在此包中增加了在并发编程中很常用的工具类。此包包括了几个小的、已标准化的可扩展框架，并提供一些功能实用的类，没有这些类，一些功能会很难实现或实现起来冗长乏味。</p>
<p>参照JDK文档：</p>
<p><img src="1562743378734.png" alt="1562743378734"></p>
<h2 id="1-2-进程和线程">1.2. 进程和线程</h2>
<p>进程：进程是一个具有一定<strong>独立功能的程序</strong>关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p>
<p>线程：通常在<strong>一个进程中可以包含若干个线程</strong>，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。</p>
<p>生活实例：</p>
<p>​		使用QQ，查看进程一定有一个QQ.exe的进程，我可以用qq和A文字聊天，和B视频聊天，给C传文件，给D发一段语言，QQ支持录入信息的搜索。</p>
<p>​		大四的时候写论文，用word写论文，同时用QQ音乐放音乐，同时用QQ聊天，多个进程。</p>
<p>​		word如没有保存，停电关机，再通电后打开word可以恢复之前未保存的文档，word也会检查你的拼写，两个线程：容灾备份，语法检查</p>
<h2 id="1-3-并行和并发">1.3. 并行和并发</h2>
<p>并发：同一时刻多个线程在访问同一个资源，多个线程对一个点</p>
<p>​      例子：小米9今天上午10点，限量抢购</p>
<p>​            春运抢票</p>
<p>​            电商秒杀…</p>
<p>并行：多项工作一起执行，之后再汇总</p>
<p>​      例子：泡方便面，电水壶烧水，一边撕调料倒入桶中</p>
<h2 id="1-4-wait-sleep的区别">1.4. wait/sleep的区别</h2>
<p>功能都是当前线程暂停，有什么区别？</p>
<p>wait：<strong>放开手去睡</strong>，放开手里的锁</p>
<p>sleep：<strong>握紧手去睡</strong>，醒了手里还有锁</p>
<p>wait是Object的方法，sleep是thread的方法</p>
<h2 id="1-5-创建线程回顾">1.5. 创建线程回顾</h2>
<p><strong>创建线程常用两种方式</strong>：</p>
<ol>
<li>继承Thread：java是单继承，资源宝贵，要用接口方式</li>
<li>实现Runable接口</li>
</ol>
<p><strong>继承Thread抽象类</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br></pre></td></tr></table></figure>
<p><strong>实现Runnable接口</strong>的方式：</p>
<ol>
<li>新建类实现runnable接口。这种方法会新增类，有更好的方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span><span class="comment">//新建类实现runnable接口</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>()， name).start <span class="comment">// 使用Rannable实现类创建进程，name是线程名</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>匿名内部类。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> 		<span class="comment">// 调用资源方法，完成业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;， <span class="string">&quot;your thread name&quot;</span>).start();</span><br></pre></td></tr></table></figure>
<h2 id="1-6-lambda表达式">1.6. lambda表达式</h2>
<p>之前说了Runnable接口的两种实现方式，其实还有第三种：</p>
<ol>
<li>创建类实现Runnable接口</li>
<li>编写匿名内部类实现Runnable接口</li>
<li><strong>lambda表达式</strong>：这种方法代码更简洁精炼</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;， &quot;your thread name&quot;).start();</span><br></pre></td></tr></table></figure>
<h3 id="1-6-1-什么是lambda">1.6.1. 什么是lambda</h3>
<p>Lambda 是一个匿名函数，我们可以把 Lambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</p>
<p>Lambda 表达式在Java 语言中引入了一个新的语法元素和操作符。这个操作符为 “-&gt;” ， 该操作符被称为 Lambda 操作符或剪头操作符。它将 Lambda 分为两个部分：</p>
<ul>
<li>左侧：指定了 Lambda 表达式需要的所有参数</li>
<li>右侧：指定了 Lambda 体，即 Lambda 表达式要执行的功能</li>
</ul>
<h3 id="1-6-2-案例">1.6.2. 案例</h3>
<p>在一个方法中调用接口中的方法：传统写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x， <span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Foo</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foo</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x， <span class="type">int</span> y)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> x + y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(foo.add(<span class="number">10</span>， <span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，要用lambda表达式改造。其实是改造main方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Foo</span> <span class="variable">foo</span> <span class="operator">=</span> (<span class="type">int</span> x， <span class="type">int</span> y)-&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(foo.add(<span class="number">10</span>， <span class="number">20</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改造口诀：<font color="red">拷贝小括号()，写死右箭头-&gt;，落地大括号{…}</font></p>
<p>思考：如果Foo接口有多个方法，还能使用lambda表达式吗？</p>
<h3 id="1-6-3-函数式接口">1.6.3. 函数式接口</h3>
<p>lambda表达式，<strong>必须是函数式接口，必须只有一个方法</strong>，如果<strong>接口只有一个方法</strong>java默认它为<strong>函数式接口</strong>。<br>
为了正确使用Lambda表达式，需要给接口加个注解：@FunctionalInterface。如有两个方法，立刻报错。</p>
<p>Runnable接口为什么可以用lambda表达式？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread， starting the thread causes the object&#x27;s</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现Runnable接口上有一个注解：@FunctionalInterface</p>
<p>并且该接口只有一个方法：run()方法</p>
<p>其实，函数式接口必须只有一个方法，这个描述并不准确，它还允许有default方法和静态方法。</p>
<p>例如，在Foo接口中，又添加了sub方法和mul方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x， <span class="type">int</span> y)</span>; <span class="comment">// 抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> x， <span class="type">int</span> y)</span>&#123; <span class="comment">// default方法</span></span><br><span class="line">        <span class="keyword">return</span> x - y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> x， <span class="type">int</span> y)</span>&#123; <span class="comment">// 静态方法</span></span><br><span class="line">        <span class="keyword">return</span> x * y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Foo</span> <span class="variable">foo</span> <span class="operator">=</span> (<span class="type">int</span> x， <span class="type">int</span> y)-&gt;&#123;  <span class="comment">// lambda表达式实现抽象方法</span></span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(foo.add(<span class="number">10</span>， <span class="number">20</span>)); <span class="comment">// 调用抽象方法</span></span><br><span class="line">        System.out.println(foo.sub(<span class="number">30</span>， <span class="number">15</span>)); <span class="comment">// 调用default方法</span></span><br><span class="line">        System.out.println(Foo.mul(<span class="number">10</span>， <span class="number">50</span>)); <span class="comment">// 通过Foo调用静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-6-4-小结">1.6.4. 小结</h3>
<p>lambda表达式实现接口的前提是</p>
<p>​		<strong>有且只有一个抽象方法，可以选择@FunctionalInterface注解增强函数式接口定义</strong></p>
<p>改造口诀</p>
<p>​		<strong>拷贝小括号(形参列表)，写死右箭头 -&gt;，落地大括号 {方法实现}</strong></p>
<h2 id="1-7-synchronized回顾">1.7. synchronized回顾</h2>
<p><font color="red">多线程编程模板上</font>：</p>
<p>​	线程 操作 资源类</p>
<p>实现步骤：</p>
<ol>
<li>创建资源类</li>
<li>资源类里创建同步方法、同步代码块</li>
<li>多线程调用</li>
</ol>
<p>例子：<strong>卖票程序</strong></p>
<p>创建工程，并添加了一个SaleTicket.java</p>
<p><img src="1562747700613.png" alt="1562747700613"></p>
<p>内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;票已售罄！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始买票，当前票数：&quot;</span> + number);</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;买票结束，剩余票数：&quot;</span> + --number);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在main方法中创建多线程方法，测试卖票业务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicket</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;， <span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;， <span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;， <span class="string">&quot;CCC&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-8-synchronized的8锁问题">1.8. synchronized的8锁问题</h2>
<p>看下面这段儿代码，回答后面的8个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//TimeUnit.SECONDS.sleep(4);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------getHello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;， <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendEmail();</span><br><span class="line">                <span class="comment">//phone.getHello();</span></span><br><span class="line">                <span class="comment">//phone2.sendEmail();</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;， <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多线程的8个问题：</p>
<ol>
<li>标准访问，先打印短信还是邮件</li>
<li>停4秒在短信方法内，先打印短信还是邮件</li>
<li>普通的hello方法，是先打短信还是hello</li>
<li>现在有两部手机，先打印短信还是邮件</li>
<li>两个静态同步方法，1部手机，先打印短信还是邮件</li>
<li>两个静态同步方法，2部手机，先打印短信还是邮件</li>
<li>1个静态同步方法，1个普通同步方法，1部手机，先打印短信还是邮件</li>
<li>1个静态同步方法，1个普通同步方法，2部手机，先打印短信还是邮件</li>
</ol>
<p>总结：</p>
<p>synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式：</p>
<ol>
<li>对于普通同步方法，锁是当前实例对象。</li>
<li>对于静态同步方法，锁是当前类的Class对象。</li>
<li>对于同步方法块，锁是Synchonized括号里配置的对象</li>
</ol>
<p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</p>
<p>也就是说：</p>
<p>如果<strong>一个实例对象</strong>的<strong>非静态同步方法</strong>获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁；</p>
<p>不同实例对象<strong>的非静态同步方法因为用的</strong>是不同对象的锁，所以无须等待其他实例对象的非静态同步方法释放锁，就可以获取自己的锁。</p>
<p><strong>所有的静态同步方法用的是同一把锁——类对象本身</strong>。不管是不是同一个实例对象，只要是一个类的对象，一旦一个静态同步方法获取锁之后，其他对象的静态同步方法，都必须等待该方法释放锁之后，才能获取锁。</p>
<p>而静态同步方法（Class对象锁）与非静态同步方法（实例对象锁）之间是不会有竞态条件的。</p>
<h3 id="1-8-1-字节码分析">1.8.1 字节码分析</h3>
<p><strong>同步代码块</strong></p>
<p><img src="20210314181051606.png" alt="20210314181051606.png"></p>
<p>如果方法中直接抛出了异常处理，那么就是一个monitorenter和一个monitorexit</p>
<p><strong>普通同步方法</strong></p>
<p><img src="2021031418130816.png" alt="2021031418130816.png"></p>
<p>调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程会将先持有monitor然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放minotor</p>
<p><strong>静态同步方法</strong></p>
<p><img src="20210314181650733.png" alt="20210314181650733.png"></p>
<p>ACC_STATIC、ACC_SYNCHRONIZED访问标志区分该方法是否静态同步方法</p>
<h3 id="1-8-2-synchronized锁的是什么">1.8.2  synchronized锁的是什么</h3>
<p><img src="https://bugstack.cn/images/2020/interview/interview-15-01.png" alt="img"></p>
<p>每个 Java 对象头中都包括 Monitor 对象(存储的指针的指向)，synchronized 也就是通过这一种方式获取锁，也就解释了为什么 synchronized() 括号里放任何对象都能获得锁🔒！</p>
<p>任何一个对象都可以成为一个锁，在HotSpot虚拟机中，monitor采用ObjectMonitor实现</p>
<p><img src="20210314181905750.png" alt="20210314181905750.png"></p>
<h3 id="1-8-3-四大特性">1.8.3 四大特性</h3>
<p>原子性、<strong>可见性</strong>、有序性、可重入性</p>
<ol>
<li>线程解锁前，必须把共享变量的最新值刷新到主内存中。</li>
<li>线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值。</li>
<li>volatile 的可见性都是通过内存屏障（Memnory Barrier）来实现的。</li>
<li>synchronized 靠操作系统内核互斥锁实现，相当于 JMM 中的 lock、unlock。退出代码块时刷新变量到主内存。</li>
</ol>
<h2 id="1-9-synchronized-性能优化">1.9 synchronized 性能优化</h2>
<p>在Java早期版本中，synchronized属于<strong>重量级</strong>锁，效率低下。因为监视器锁(monitor)是依赖于底层的操作系统的Mutex Lock来实现的，挂起线程和恢复线程都需要转入内核态去完成，阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态切换需要耗费处理器时间</p>
<blockquote>
<p>每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。 依赖于底层的操作系统的Mutex Lock。</p>
</blockquote>
<p><img src="20210627111318375.png" alt="20210627111318375.png"></p>
<p>synchronized 锁有四种交替升级的状态：无锁、偏向锁、轻量级锁和重量级，这几个状态随着竞争情况逐渐升级。</p>
<h3 id="偏向锁">偏向锁</h3>
<p>当一段同步代码一直被同一个线程多次访问，由于只有一个线程，那么该线程在后续访问时便会自动获得锁(偏向锁)</p>
<p>同一个老顾客来访，直接老规矩行方便。偏向锁为了解决只有在一个线程执行同步时提高性能</p>
<p><strong>原理：</strong></p>
<ol>
<li>在锁第一次被拥有的时候，记录下偏向线程ID。这样偏向线程就一直持有着锁(后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁。而是直接比较对象头里面是否存储了指向当前线程的偏向锁)。</li>
<li>如果相等表示偏向锁是偏向于当前线程的，就不需要再尝试获得锁了，直到竞争发生才释放锁。以后每次同步，判断一下是否有偏向锁指向本身的ID，如果一致直接进入同步。无需每次加锁解锁都去CAS更新对象头。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</li>
<li>假如不一致意味着发生了竞争，锁已经不是总是偏向于同一个线程了，这时候可能需要升级变为轻量级锁，才能保证线程间公平竞争锁。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的</li>
</ol>
<p><img src="20210627172143981.png" alt="20210627172143981.png"></p>
<h3 id="轻量锁">轻量锁</h3>
<p>当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p>
<p>假如线程A已经拿到锁，这时线程B又来抢该对象的锁，由于该对象的锁已经被线程A拿到，当前该锁已是偏向锁了。<br>
而线程B在争抢时发现对象头Mark Word中的线程ID不是线程B自己的线程ID(而是线程A)，那线程B就会进行CAS操作希望能获得锁。<br>
<strong>此时线程B操作中有两种情况</strong><br>
如果锁获取成功，直接替换Mark Word中的线程ID为B自己的ID(A → B)，重新偏向于其他线程(即将偏向锁交给其他线程，相当于当前线程&quot;被&quot;释放了锁)，该锁会保持偏向锁状态，A线程Over，B线程上位</p>
<p>如果锁获取失败，则偏向锁升级为轻量级锁，此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程B会进入自旋等待获得该轻量级锁。</p>
<p><img src="20210627173800380.png" alt="20210627173800380.png"></p>
<h3 id="锁膨胀-重量级锁">锁膨胀-&gt;重量级锁</h3>
<p>在尝试加轻量级锁的过程中，CAS 操作无法成功，可能是其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p>
<p><strong>重量级锁竞争</strong>时，尝试获取锁的线程不会立即阻塞，可以使用自旋（默认 10 次）来进行优化，采用循环的方式去尝试获取锁，自旋失败的线程会进入阻塞状态</p>
<h3 id="锁销除">锁销除</h3>
<p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除，这是 JVM 即时编译器的优化</p>
<p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除（同步消除：JVM 逃逸分析）</p>
<h3 id="锁粗化">锁粗化</h3>
<p>对相同对象多次加锁，导致线程发生多次重入，频繁的加锁操作就会导致性能损耗，可以使用锁粗化方式优化</p>
<p>如果虚拟机探测到一串的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部</p>
<h2 id="大图总结">大图总结</h2>
<p><img src="https://bugstack.cn/images/2020/interview/interview-15-07.png" alt="img"></p>
<h1>2. Lock锁</h1>
<p>首先看一下JUC的重磅武器——锁（Lock）</p>
<p>相比同步锁，JUC包中的Lock锁的功能更加强大，它提供了各种各样的锁（公平锁，非公平锁，共享锁，独占锁……），所以使用起来很灵活。</p>
<p><img src="1562748499107.png" alt="1562748499107"></p>
<p>翻译过来就是：</p>
<blockquote>
<p>锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象。</p>
</blockquote>
<p>Lock是一个接口，这里主要有三个实现：ReentrantLock、ReentrantReadWriteLock.ReadLock、ReentrantReadWriteLock.WriteLock</p>
<h2 id="2-1-ReentrantLock可重入锁">2.1. ReentrantLock可重入锁</h2>
<p>ReentrantLock使用方式参照官方文档：</p>
<p><img src="1562757277239.png" alt="1562757277239"></p>
<p>使用ReentrantLock改造卖票程序：只需改造sale()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (number &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;票已售罄！&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;买票成功，当前剩余：&quot;</span> + number);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-1-测试可重入性">2.1.1. 测试可重入性</h3>
<p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是<strong>可一定程度避免死锁</strong>。</p>
<p>例如下列伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> aa&#123;</span><br><span class="line">		......</span><br><span class="line">        bb();</span><br><span class="line">        ......</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> bb&#123;</span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">a.aa();</span><br></pre></td></tr></table></figure>
<p>A类中有两个普通同步方法，都需要对象a的锁。如果是不可重入锁的话，aa方法首先获取到锁，aa方法在执行的过程中需要调用bb方法，此时锁被aa方法占有，bb方法无法获取到锁，这样就会导致bb方法无法执行，aa方法也无法执行，出现了死锁情况。可重入锁可避免这种死锁的发生。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (number &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;票已售罄！&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;买票成功，当前剩余：&quot;</span> + number);</span><br><span class="line">            <span class="comment">// 调用check方法测试锁的可重入性</span></span><br><span class="line">            <span class="built_in">this</span>.check();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为了测试可重入锁，添加检查余票方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;检查余票。。。。&quot;</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现程序可以正常执行。。。说明该锁确实可重入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">AAA买票成功，当前剩余：19</span><br><span class="line">检查余票。。。。</span><br><span class="line">AAA买票成功，当前剩余：18</span><br><span class="line">检查余票。。。。</span><br><span class="line">AAA买票成功，当前剩余：17</span><br><span class="line">检查余票。。。。</span><br><span class="line">AAA买票成功，当前剩余：16</span><br><span class="line">检查余票。。。。</span><br><span class="line">AAA买票成功，当前剩余：15</span><br><span class="line">检查余票。。。。</span><br><span class="line">AAA买票成功，当前剩余：14</span><br><span class="line">检查余票。。。。</span><br><span class="line">AAA买票成功，当前剩余：13</span><br><span class="line">检查余票。。。。</span><br><span class="line">BBB买票成功，当前剩余：12</span><br><span class="line">检查余票。。。。</span><br><span class="line">BBB买票成功，当前剩余：11</span><br><span class="line">检查余票。。。。</span><br><span class="line">BBB买票成功，当前剩余：10</span><br><span class="line">。。。。。。</span><br></pre></td></tr></table></figure>
<h3 id="2-1-2-测试公平锁">2.1.2. 测试公平锁</h3>
<p>ReentrantLock还可以实现公平锁。所谓公平锁，也就是在锁上等待时间最长的线程将获得锁的使用权。通俗的理解就是谁排队时间最长谁先执行获取锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AAA买票成功，当前剩余：19</span><br><span class="line">检查余票。。。。</span><br><span class="line">BBB买票成功，当前剩余：18</span><br><span class="line">检查余票。。。。</span><br><span class="line">CCC买票成功，当前剩余：17</span><br><span class="line">检查余票。。。。</span><br><span class="line">AAA买票成功，当前剩余：16</span><br><span class="line">检查余票。。。。</span><br><span class="line">BBB买票成功，当前剩余：15</span><br><span class="line">检查余票。。。。</span><br><span class="line">CCC买票成功，当前剩余：14</span><br><span class="line">。。。。。。</span><br></pre></td></tr></table></figure>
<p>可以看到ABC三个线程是按顺序买票成功的。</p>
<h3 id="2-1-3-限时等待">2.1.3. 限时等待</h3>
<p>这个是什么意思呢？也就是通过我们的tryLock方法来实现，可以选择传入时间参数，表示等待指定的时间，无参则表示立即返回锁申请的结果：true表示获取锁成功，false表示获取锁失败。我们可以将这种方法用来解决死锁问题。</p>
<p><img src="1595084697591.png" alt="1595084697591"></p>
<h3 id="2-1-4-ReentrantLock和synchronized区别">2.1.4. ReentrantLock和synchronized区别</h3>
<p>隐式显式、可中断、公平性、性能</p>
<p>（1）synchronized是独占锁，加锁和解锁的过程自动进行，易于操作，但不够灵活。ReentrantLock也是独占锁，加锁和解锁的过程需要手动进行，不易操作，但非常灵活。</p>
<p>（2）synchronized可重入，因为加锁和解锁自动进行，不必担心最后是否释放锁；ReentrantLock也可重入，但加锁和解锁需要手动进行，且次数需一样，否则其他线程无法获得锁。</p>
<ul>
<li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li>
<li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li>
<li>其他：synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</li>
</ul>
<h2 id="2-2-ReentrantReadWriteLock读写锁">2.2. ReentrantReadWriteLock读写锁</h2>
<p>​		在并发场景中用于解决线程安全的问题，我们几乎会高频率的使用到独占式锁，通常使用java提供的关键字synchronized或者concurrents包中实现了Lock接口的ReentrantLock。它们都是独占式获取锁，也就是在同一时刻只有一个线程能够获取锁。而在一些业务场景中，大部分只是读数据，写数据很少，如果仅仅是读数据的话并不会影响数据正确性（出现脏读），而如果在这种业务场景下，依然使用独占锁的话，很显然这将是出现性能瓶颈的地方。针对这种读多写少的情况，java还提供了另外一个实现Lock接口的<strong>ReentrantReadWriteLock</strong>(读写锁)。<strong>读写锁允许同一时刻被多个读线程访问，但是在写线程访问时，所有的读线程和其他的写线程都会被阻塞</strong>。</p>
<p>读写锁的特点：</p>
<ol>
<li>写写不可并发</li>
<li>读写不可并发</li>
<li>读读可以并发</li>
</ol>
<h3 id="2-2-1-重写读写问题">2.2.1. 重写读写问题</h3>
<p>接下来以缓存为例用代码演示读写锁，重现问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCache</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String， String&gt; cache= <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key， String value)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始写入！&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">300</span>);</span><br><span class="line">            cache.put(key， value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 写入成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始读出！&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">300</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 读出成功！&quot;</span> + value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantReadWriteLockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">MyCache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCache</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line">            <span class="comment">// 开启5个写线程</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                cache.put(num， num);</span><br><span class="line">            &#125;， num).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line">            <span class="comment">// 开启5个读线程</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                cache.get(num);</span><br><span class="line">            &#125;， num).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：多执行几次，有很大概率不会出现问题</p>
<p><img src="1562978827184.png" alt="1562978827184"></p>
<h3 id="2-2-2-读写锁的使用">2.2.2. 读写锁的使用</h3>
<p>改造MyCache，加入读写锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCache</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String， String&gt; cache= <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 加入读写锁</span></span><br><span class="line">    <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key， String value)</span>&#123;</span><br><span class="line">        <span class="comment">// 加写锁</span></span><br><span class="line">        rwl.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始写入！&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            cache.put(key， value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 写入成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放写锁</span></span><br><span class="line">            rwl.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        <span class="comment">// 加入读锁</span></span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始读出！&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 读出成功！&quot;</span> + value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放读锁</span></span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-3-锁降级">2.2.3. 锁降级</h3>
<p>什么是锁降级，锁降级就是从写锁降级成为读锁。在当前线程拥有写锁的情况下，再次获取到读锁，随后释放写锁的过程就是锁降级。这里可以举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    rwlock.writeLock().lock();</span><br><span class="line">    System.out.println(<span class="string">&quot;获取到写锁。。。。&quot;</span>);</span><br><span class="line">    rwlock.readLock().lock();</span><br><span class="line">    System.out.println(<span class="string">&quot;获取到读锁----------&quot;</span>);</span><br><span class="line">    rwlock.writeLock().unlock();</span><br><span class="line">    System.out.println(<span class="string">&quot;释放写锁==============&quot;</span>);</span><br><span class="line">    rwlock.readLock().unlock();</span><br><span class="line">    System.out.println(<span class="string">&quot;释放读锁++++++++++++++++&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印效果：</p>
<p><img src="1615101148093.png" alt="1615101148093"></p>
<h3 id="2-2-4-读写锁总结">2.2.4. 读写锁总结</h3>
<ol>
<li>
<p>支持公平/非公平策略</p>
<p><img src="1615100164370.png" alt="1615100164370"></p>
</li>
<li>
<p>支持可重入</p>
<ul>
<li>同一读线程在获取了读锁后还可以获取读锁</li>
<li>同一写线程在获取了写锁之后既可以再次获取写锁又可以获取读锁</li>
</ul>
</li>
<li>
<p>支持锁降级，不支持锁升级</p>
</li>
<li>
<p>读写锁如果使用不当，很容易产生“饥饿”问题：</p>
<p>在读线程非常多，写线程很少的情况下，很容易导致写线程“饥饿”，虽然使用“公平”策略可以一定程度上缓解这个问题，但是“公平”策略是以牺牲系统吞吐量为代价的。</p>
</li>
<li>
<p>Condition条件支持</p>
<p>写锁可以通过<code>newCondition()</code>方法获取Condition对象。但是读锁是没法获取Condition对象，读锁调用<code>newCondition() </code>方法会直接抛出<code>UnsupportedOperationException</code>。</p>
</li>
</ol>
<h1>3. 线程间通信</h1>
<p>面试题：两个线程打印</p>
<p>​	两个线程，一个线程打印1-52，另一个打印字母A-Z打印顺序为12A34B…5152Z，要求用线程间通信</p>
<h2 id="3-1-回顾线程通信">3.1. 回顾线程通信</h2>
<p>先来简单案例：</p>
<p>​	两个线程操作一个初始值为0的变量，实现一个线程对变量增加1，一个线程对变量减少1，交替10轮。</p>
<p>线程间通信模型：</p>
<ol>
<li>生产者+消费者</li>
<li>通知等待唤醒机制</li>
</ol>
<p>多线程编程模板中：</p>
<ol>
<li>
<p>判断</p>
</li>
<li>
<p>干活</p>
</li>
<li>
<p>通知</p>
</li>
</ol>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShareDataOne</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  增加1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1. 判断</span></span><br><span class="line">        <span class="keyword">if</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 干活</span></span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + number);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 通知</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 减少1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1. 判断</span></span><br><span class="line">        <span class="keyword">if</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 干活</span></span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + number);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 通知</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 现在两个线程，</span></span><br><span class="line"><span class="comment"> * 可以操作初始值为零的一个变量，</span></span><br><span class="line"><span class="comment"> * 实现一个线程对该变量加1，一个线程对该变量减1，</span></span><br><span class="line"><span class="comment"> * 交替，来10轮。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 笔记：Java里面如何进行工程级别的多线程编写</span></span><br><span class="line"><span class="comment"> * 1 多线程变成模板（套路）-----上</span></span><br><span class="line"><span class="comment"> *    1.1  线程    操作    资源类</span></span><br><span class="line"><span class="comment"> *    1.2  高内聚  低耦合</span></span><br><span class="line"><span class="comment"> * 2 多线程变成模板（套路）-----中</span></span><br><span class="line"><span class="comment"> *    2.1  判断</span></span><br><span class="line"><span class="comment"> *    2.2  干活</span></span><br><span class="line"><span class="comment"> *    2.3  通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotifyWaitDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ShareDataOne</span> <span class="variable">shareDataOne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareDataOne</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    shareDataOne.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;， <span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    shareDataOne.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;， <span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>部分打印结果：AAA和BBB交互执行，执行结果是1 0 1 0… 一共10轮</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AAA: 1</span><br><span class="line">BBB: 0</span><br><span class="line">AAA: 1</span><br><span class="line">BBB: 0</span><br><span class="line">AAA: 1</span><br><span class="line">BBB: 0</span><br><span class="line">AAA: 1</span><br><span class="line">BBB: 0</span><br><span class="line">。。。。</span><br></pre></td></tr></table></figure>
<p><strong>如果换成4个线程会怎样？</strong></p>
<p>改造mian方法，加入CCC和DDD两个线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ShareDataOne</span> <span class="variable">shareDataOne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareDataOne</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                shareDataOne.increment();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;， <span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                shareDataOne.decrement();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;， <span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                shareDataOne.increment();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;， <span class="string">&quot;CCC&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                shareDataOne.decrement();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;， <span class="string">&quot;DDD&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果，依然会有概率是，10101010…。</p>
<p>但是，多执行几次，也会出现错乱的现象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AAA: 1</span><br><span class="line">BBB: 0</span><br><span class="line">CCC: 1</span><br><span class="line">AAA: 2</span><br><span class="line">CCC: 3</span><br><span class="line">BBB: 2</span><br><span class="line">CCC: 3</span><br><span class="line">DDD: 2</span><br><span class="line">AAA: 3</span><br><span class="line">DDD: 2</span><br><span class="line">CCC: 3</span><br><span class="line">BBB: 2</span><br></pre></td></tr></table></figure>
<h2 id="3-2-虚假唤醒">3.2. 虚假唤醒</h2>
<p>换成4个线程会导致错误，<strong>虚假唤醒</strong></p>
<p>原因：在java多线程判断时，不能用if，程序出事出在了判断上面。</p>
<p>**注意，消费者被唤醒后是从wait()方法（被阻塞的地方）后面执行，而不是重新从同步块开头。**从阻塞态到就绪态再到运行态没有进行判断，我们只需要让其每次得到操作权时都进行判断就可以了 。</p>
<p>如下图：</p>
<p><img src="1562811518605.png" alt="1562811518605"></p>
<p>解决	虚假唤醒：查看API，java.lang.Object的wait方法</p>
<p><img src="1562810523532.png" alt="1562810523532"></p>
<p>中断和虚假唤醒是可能产生的，所以要用loop循环，if只判断一次，while是只要唤醒就要拉回来再判断一次。</p>
<p>if换成while</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShareDataOne</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  增加1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1. 判断</span></span><br><span class="line">        <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 干活</span></span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + number);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 通知</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 减少1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1. 判断</span></span><br><span class="line">        <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 干活</span></span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + number);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 通知</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 现在两个线程，</span></span><br><span class="line"><span class="comment"> * 可以操作初始值为零的一个变量，</span></span><br><span class="line"><span class="comment"> * 实现一个线程对该变量加1，一个线程对该变量减1，</span></span><br><span class="line"><span class="comment"> * 交替，来10轮。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 笔记：Java里面如何进行工程级别的多线程编写</span></span><br><span class="line"><span class="comment"> * 1 多线程变成模板（套路）-----上</span></span><br><span class="line"><span class="comment"> *    1.1  线程    操作    资源类</span></span><br><span class="line"><span class="comment"> *    1.2  高内聚  低耦合</span></span><br><span class="line"><span class="comment"> * 2 多线程变成模板（套路）-----中</span></span><br><span class="line"><span class="comment"> *    2.1  判断</span></span><br><span class="line"><span class="comment"> *    2.2  干活</span></span><br><span class="line"><span class="comment"> *    2.3  通知</span></span><br><span class="line"><span class="comment"> * 3 多线程编程模板（套路）-----下</span></span><br><span class="line"><span class="comment"> *    防止虚假唤醒（while）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotifyWaitDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ShareDataOne</span> <span class="variable">shareDataOne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareDataOne</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    shareDataOne.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;， <span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    shareDataOne.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;， <span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    shareDataOne.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;， <span class="string">&quot;CCC&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    shareDataOne.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;， <span class="string">&quot;DDD&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次测试，完美解决</p>
<h2 id="3-3-线程通信（Condition）">3.3. 线程通信（Condition）</h2>
<p>对标synchronized：</p>
<p><img src="1562812279119.png" alt="1562812279119"></p>
<p>Condition：查看API，java.util.concurrent.locks</p>
<p><img src="1562812425080.png" alt="1562812425080"></p>
<p>并提供了实现案例：</p>
<p><img src="1562812570735.png" alt="1562812570735"></p>
<p>使用Condition实现线程通信，改造之前的代码（只需要改造ShareDataOne）：<strong>删掉increment和decrement方法的synchronized</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShareDataOne</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">// 初始化lock锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition(); <span class="comment">// 初始化condition对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  增加1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 加锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// this.wait();</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 干活</span></span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + number);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 通知</span></span><br><span class="line">            <span class="comment">// this.notifyAll();</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 减少1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// this.wait();</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 干活</span></span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + number);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 通知</span></span><br><span class="line">            <span class="comment">//this.notifyAll();</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-4-定制化调用通信">3.4. 定制化调用通信</h2>
<p>案例：</p>
<p>​		多线程之间按顺序调用，实现A-&gt;B-&gt;C。三个线程启动，要求如下：</p>
<p>​		AA打印5次，BB打印10次，CC打印15次</p>
<p>​		接着</p>
<p>​		AA打印5次，BB打印10次，CC打印15次</p>
<p>​		。。。打印10轮</p>
<p>分析实现方式：</p>
<ol>
<li>有一个锁Lock，3把钥匙Condition</li>
<li>有顺序通知（切换线程），需要有标识位</li>
<li>判断标志位</li>
<li>输出线程名 + 内容</li>
<li>修改标识符，通知下一个</li>
</ol>
<p>具体实现：</p>
<p><img src="1562813671321.png" alt="1562813671321"></p>
<p>内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShareDataTwo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 线程标识位，通过它区分线程切换</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print5</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">1</span>) &#123;</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + (i + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print10</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">2</span>) &#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + (i + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print15</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">3</span>) &#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + (i + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多线程之间按顺序调用，实现A-&gt;B-&gt;C</span></span><br><span class="line"><span class="comment"> * 三个线程启动，要求如下：</span></span><br><span class="line"><span class="comment"> * AA打印5次，BB打印10次，CC打印15次</span></span><br><span class="line"><span class="comment"> * 接着</span></span><br><span class="line"><span class="comment"> * AA打印5次，BB打印10次，CC打印15次</span></span><br><span class="line"><span class="comment"> * ......来10轮</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadOrderAccess</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ShareDataTwo</span> <span class="variable">sdt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareDataTwo</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                sdt.print5();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;， <span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                sdt.print10();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;， <span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                sdt.print15();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;， <span class="string">&quot;CCC&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>8. ThreadPool线程池</h1>
<p>例子：<br>
10年前单核CPU电脑，假的多线程，像马戏团小丑玩多个球，CPU需要来回切换。<br>
现在是多核电脑，多个线程各自跑在独立的CPU上，不用切换效率高。</p>
<p>线程池的优势：线程复用；控制最大并发数；管理线程。</p>
<ol>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的销耗。​​</li>
<li>提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ol>
<h2 id="8-1-架构说明">8.1. 架构说明</h2>
<p>Java中的线程池是通过Executor框架实现的，该框架中用到了Executor，ExecutorService，ThreadPoolExecutor这几个类。</p>
<p><img src="1562997049227.png" alt="1562997049227"></p>
<p>Executor接口是顶层接口，只有一个execute方法，过于简单。通常不使用它，而是使用ExecutorService接口：</p>
<p><img src="1562998979772.png" alt="1562998979772"></p>
<p>那么问题来了，怎么创建一个连接池对象呢？通常使用Executors工具类</p>
<h2 id="8-2-Executors工具类">8.2. Executors工具类</h2>
<p>架构图可以看到Executors工具类，有没有联想到Collections，Arrays等。没错，可以用它快速创建线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Arrays.asList(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>
<p><img src="1562997592723.png" alt="1562997592723"></p>
<p>直接编码演示：每种连接池的效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建单一线程的连接池</span></span><br><span class="line">        <span class="comment">// ExecutorService threadPool = Executors.newSingleThreadExecutor();</span></span><br><span class="line">        <span class="comment">// ExecutorService threadPool = Executors.newFixedThreadPool(3);</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                threadPool.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了业务逻辑&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-3-底层原理">8.3. 底层原理</h2>
<p>上述案例中的三个方法的本质都是ThreadPoolExecutor的实例化对象，只是具体参数值不同。</p>
<p><img src="1562999783113.png" alt="1562999783113"></p>
<h3 id="8-3-1-线程池的7个重要参数">8.3.1. 线程池的7个重要参数</h3>
<p><img src="1563002258102.png" alt="1563002258102"></p>
<ol>
<li>corePoolSize：线程池中的常驻核心线程数</li>
<li>maximumPoolSize：线程池中能够容纳同时 执行的最大线程数，此值必须大于等于1</li>
<li>keepAliveTime：多余的空闲线程的存活时间 当前池中线程数量超过corePoolSize时，当空闲时间达到keepAliveTime时，多余线程会被销毁直到 只剩下corePoolSize个线程为止</li>
<li>unit：keepAliveTime的单位</li>
<li>workQueue：任务队列，被提交但尚未被执行的任务</li>
<li>threadFactory：表示生成线程池中工作线程的线程工厂， 用于创建线程，<strong>一般默认的即可</strong></li>
<li>handler：拒绝策略，表示当队列满了，并且工作线程大于 等于线程池的最大线程数（maximumPoolSize）时，如何来拒绝 请求执行的runnable的策略</li>
</ol>
<p><img src="https://kanban.oss-cn-hangzhou.aliyuncs.com/63e1baef52364e20b3eec052.png?Expires=1675778538&amp;OSSAccessKeyId=LTAItvN1XkWqIhQR&amp;Signature=5YguAkYgbndKRVEgiwrVtCSOXH0%3D&amp;x-oss-process=image%2Fauto-orient%2C1" alt="img"></p>
<h3 id="8-3-2-线程池底层工作原理">8.3.2. 线程池底层工作原理</h3>
<p>具体流程：</p>
<p><img src="2599999-81ce63806c457a4c.png" alt="img"></p>
<p>重要的事情说三遍：<font color="red">以下重要：以下重要：以下重要：</font></p>
<ol>
<li>
<p>在创建了线程池后，线程池中的<strong>线程数为零</strong>。</p>
</li>
<li>
<p>当调用execute()方法添加一个请求任务时，线程池会做出如下判断：</p>
<ol>
<li>如果正在运行的线程数量<strong>小于corePoolSize</strong>，那么马上<strong>创建线程</strong>运行这个任务；</li>
<li>如果正在运行的线程数量<strong>大于或等于corePoolSize</strong>，那么<strong>将这个任务放入队列</strong>；</li>
<li>如果这个时候队列满了且正在运行的线程数量还<strong>小于maximumPoolSize</strong>，那么还是要<strong>创建非核心线程</strong>立刻运行这个任务；</li>
<li>如果队列满了且正在运行的线程数量<strong>大于或等于maximumPoolSize</strong>，那么线程池会<strong>启动饱和拒绝策略</strong>来执行。</li>
</ol>
</li>
<li>
<p>当一个线程完成任务时，它会从队列中取下一个任务来执行。</p>
</li>
<li>
<p>当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：</p>
<p>如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。</p>
<p>所以线程池的所有任务完成后，<strong>它最终会收缩到corePoolSize的大小</strong>。</p>
</li>
</ol>
<h3 id="8-3-3-拒绝策略">8.3.3. 拒绝策略</h3>
<p>一般我们创建线程池时，为防止资源被耗尽，任务队列都会选择创建有界任务队列，但这种模式下如果出现<strong>任务队列已满且线程池创建的线程数达到你设置的最大线程数时</strong>，这时就需要你指定ThreadPoolExecutor的RejectedExecutionHandler参数即合理的拒绝策略，来处理线程池&quot;超载&quot;的情况。</p>
<p>ThreadPoolExecutor自带的拒绝策略如下：</p>
<ol>
<li>AbortPolicy(默认)：直接<strong>抛出RejectedExecutionException异常</strong>阻止系统正常运行</li>
<li>CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是<strong>将某些任务回退到调用者</strong>，从而降低新任务的流量。</li>
<li>DiscardOldestPolicy：<strong>抛弃队列中等待最久的任务</strong>，然后把当前任务加人队列中 尝试再次提交当前任务。</li>
<li>DiscardPolicy：<strong>该策略默默地丢弃无法处理的任务</strong>，不予任何处理也不抛出异常。 如果允许任务丢失，这是最好的一种策略。</li>
</ol>
<p><strong>以上内置的策略均实现了RejectedExecutionHandler接口，也可以自己扩展RejectedExecutionHandler接口，定义自己的拒绝策略</strong></p>
<h2 id="8-4-自定义线程池">8.4. 自定义线程池</h2>
<p>​		在《阿里巴巴java开发手册》中指出了线程资源必须通过线程池提供，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优化了资源的开销。而线程池不允许使用Executors去创建，而要通过ThreadPoolExecutor方式，这一方面是由于jdk中Executor框架虽然提供了如newFixedThreadPool()、newSingleThreadExecutor()、newCachedThreadPool()等创建线程池的方法，但都有其局限性，不够灵活；使用ThreadPoolExecutor有助于大家明确线程池的运行规则，创建符合自己的业务场景需要的线程池，避免资源耗尽的风险。</p>
<p><img src="1563004545584.png" alt="1563004545584"></p>
<p>自定义线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建单一线程的连接池</span></span><br><span class="line">        <span class="comment">// ExecutorService threadPool = Executors.newSingleThreadExecutor();</span></span><br><span class="line">        <span class="comment">// 创建固定数线程的连接池</span></span><br><span class="line">        <span class="comment">// ExecutorService threadPool = Executors.newFixedThreadPool(3);</span></span><br><span class="line">        <span class="comment">// 可扩容连接池</span></span><br><span class="line">        <span class="comment">// ExecutorService threadPool = Executors.newCachedThreadPool();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义连接池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>， <span class="number">5</span>，</span><br><span class="line">                <span class="number">2</span>， TimeUnit.SECONDS， <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>)，</span><br><span class="line">                Executors.defaultThreadFactory()，</span><br><span class="line">                <span class="comment">//new ThreadPoolExecutor.AbortPolicy()</span></span><br><span class="line">                <span class="comment">//new ThreadPoolExecutor.CallerRunsPolicy()</span></span><br><span class="line">                <span class="comment">//new ThreadPoolExecutor.DiscardOldestPolicy()</span></span><br><span class="line">                <span class="comment">//new ThreadPoolExecutor.DiscardPolicy()</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">RejectedExecutionHandler</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r， ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;自定义拒绝策略&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了业务逻辑&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>9. 多线程高并发底层原理</h1>
<p>计算机运行架构图，如下：</p>
<p><img src="12353432421345.jpg" alt=""></p>
<p>由于cpu的运行程序速度远大于主存储的速度，所以会在主存RAM和CPU之间加多级高速缓存，缓存的速度接近cpu的运行速度，这样会大大提高计算机的运行速度。</p>
<h2 id="9-1-java内存模型（JMM）">9.1. java内存模型（JMM）</h2>
<p>JMM即为JAVA 内存模型（java memory model）。因为在不同的硬件生产商和不同的操作系统下，内存的访问逻辑有一定的差异，结果就是当你的代码在某个系统环境下运行良好，并且线程安全，但是换了个系统就出现各种问题。</p>
<p>Java内存模型，就是为了屏蔽系统和硬件的差异，让一套代码在不同平台下能到达相同的访问结果。</p>
<p>一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现：</p>
<p><img src="20210601180317463.png" alt="img"></p>
<p>不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成</p>
<p>JMM规定了内存主要划分为<strong>主内存</strong>和<strong>工作内存</strong>两种。</p>
<blockquote>
<p><strong>主内存</strong>：保存了所有的变量。<br>
<strong>共享变量</strong>：如果一个变量被多个线程使用，那么这个变量会在每个线程的工作内存中保有一个副本，这种变量就是共享变量。<br>
<strong>工作内存</strong>：每个线程都有自己的工作内存，线程独享，保存了线程用到的变量副本（主内存共享变量的一份拷贝）。工作内存负责与线程交互，也负责与主内存交互。</p>
</blockquote>
<p>此处的主内存和工作内存跟JVM内存划分（堆、栈、方法区）是在不同的维度上进行的，如果非要对应起来，主内存对应的是Java堆中的对象实例部分，工作内存对应的是栈中的部分区域，从更底层的来说，<strong>主内存对应的是硬件的物理内存，工作内存对应的是寄存器和高速缓存</strong>。</p>
<p>JMM对共享内存的操作做出了如下两条规定：</p>
<blockquote>
<ul>
<li>线程对共享内存的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写；</li>
<li>不同线程无法直接访问其他线程工作内存中的变量，因此共享变量的值传递需要通过主内存完成。</li>
</ul>
</blockquote>
<p>内存模型的三大特性：</p>
<ul>
<li><strong>原子性：<strong>即不可分割性。比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作是原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要</strong>使用同步技术（sychronized）或者锁（Lock）来让它变成一个原子操作</strong>。一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：<strong>AtomicInteger、AtomicLong、AtomicReference</strong>等。</li>
<li>**可见性：**每个线程都有自己的工作内存，所以当某个线程修改完某个变量之后，在其他的线程中，未必能观察到该变量已经被修改。**在 Java 中 volatile、synchronized 和 final 实现可见性。**volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。</li>
<li>**有序性：**java的有序性跟线程相关。一个线程内部所有操作都是有序的，如果是多个线程所有操作都是无序的。因为JMM的工作内存和主内存之间存在延迟，而且java会对一些指令进行重新排序。volatile和synchronized可以保证程序的有序性，很多程序员只理解这两个关键字的执行互斥，而没有很好的理解到volatile和synchronized也能保证指令不进行重排序。
<ul>
<li>volatile关键字本身就包含了禁止指令重排序的语义</li>
<li>synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入</li>
</ul>
</li>
</ul>
<h2 id="9-2-volatile关键字">9.2. volatile关键字</h2>
<p><code>volatile</code> 关键字可以保证变量的可见性，如果我们将变量声明为 <strong>volatile</strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>
<p>不能保证数据的原子性。 很多人会误认为自增操作 <code>inc++</code> 是原子性的，实际上，<code>inc++</code> 其实是一个复合操作，包括三步：</p>
<ol>
<li>读取 inc 的值。</li>
<li>对 inc 加 1。</li>
<li>将 inc 的值写回内存。</li>
</ol>
<p><code>volatile</code> 是无法保证这三个操作是具有原子性的</p>
<p><strong>防止 JVM 的指令重排序。</strong>  在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。</p>
<h3 id="9-2-1-验证可见性">9.2.1. 验证可见性</h3>
<p>验证volatile关键字保证内存可见性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是子线程工作内存flag的值：&quot;</span> + flag);</span><br><span class="line">                <span class="keyword">while</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程操作结束...&quot;</span> + flag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        flag = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是主线程工作内存flag的值：&quot;</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是没有添加volatile关键字，打印效果如下：</p>
<p><img src="1595131719599.png" alt="1595131719599"></p>
<p>子线程读取不到主线程修改后的flag值，陷入死循环程序无法结束。</p>
<p>接下来添加volatile关键字再试试：</p>
<p><img src="1595131854559.png" alt="1595131854559"></p>
<p>打印结果如下：子线程可以读取的新值并结束子线程</p>
<p><img src="1595132060909.png" alt="1595132060909"></p>
<h3 id="9-2-2-验证有序性">9.2.2. 验证有序性</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileOrderDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> a，b;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> x，y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            a = b = x = y = <span class="number">0</span>;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                a = <span class="number">1</span>;</span><br><span class="line">                x = b;</span><br><span class="line">            &#125;， <span class="string">&quot;&quot;</span>);	</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                b = <span class="number">1</span>;</span><br><span class="line">                y = a;</span><br><span class="line">            &#125;， <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">            thread1.start();</span><br><span class="line">            thread2.start();</span><br><span class="line"></span><br><span class="line">            thread1.join();</span><br><span class="line">            thread2.join();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;次打印：x=&quot;</span> + x + <span class="string">&quot;， y=&quot;</span> + y);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常情况下：</p>
<p>如果thread1先执行，xy的值是[0， 1] ；a=1 x=b {b:0} b=1 y=a {a:1};  x=0，y=1</p>
<p>如果thread2先执行是[1， 0]  b = 1 y=a {a:0} a=1 x=b{b:1}</p>
<p>如果出现[0， 0]，则说明进行了指令重排{因为JMM的工作内存和主内存之间存在延迟}。</p>
<p>thread1.b = main.b</p>
<p>thread1.a = main.a</p>
<p>thread1.x = main.x</p>
<p>thread1.y = main.y</p>
<p>a = 1;   x = b;</p>
<p>1:  thread1.a =1;</p>
<p>2: main.a=thread1.a</p>
<p>3: thread1.x = thread1.b;</p>
<p>4: main.x=thread1.x</p>
<hr>
<p>a: thread2.b = main.b</p>
<p>b: thread2.a = main.a</p>
<p>c: thread2.x = main.x</p>
<p>d: thread2.y = main.y</p>
<p>b = 1;   y = a;</p>
<p>5: thread2.b = 1;</p>
<p>6: main.b = thread2.b</p>
<p>7: thread2.y = thread2.a;</p>
<p>8: main.y=thread2.y</p>
<p>0 ：0   4，8重排   1，b，2，3，5，6，7再 4，8</p>
<p><img src="1597722920432.png" alt="1597722920432"></p>
<p>给a， b添加volatile关键字</p>
<p><img src="1597722989205.png" alt="1597722989205"></p>
<h3 id="9-2-3-验证不具备原子性">9.2.3. 验证不具备原子性</h3>
<p>编写如下程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataOne</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">incr</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ++number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileAtomicDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">DataOne</span> <span class="variable">dataOne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOne</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(dataOne.incr());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行效果如下：</p>
<p><img src="1595139693744.png" alt="1595139693744"></p>
<p>1000个线程执行++number操作，如果++number操作具备原子性，最后的值应该是1000。说明++number<strong>不具备原子性</strong>。</p>
<p>接下来，给number添加volatile关键字：</p>
<p><img src="1595139881680.png" alt="1595139881680"></p>
<p>测试结果依然不是1000，如下：</p>
<p><img src="1595139950199.png" alt="1595139950199"></p>
<p>说明volatile关键字不能保证原子性。</p>
<p>给incr方法添加同步锁试试：</p>
<p><img src="1595140034590.png" alt="1595140034590"></p>
<p>测试：</p>
<p><img src="1595140073777.png" alt="1595140073777"></p>
<p>效果完美！</p>
<h3 id="9-2-4-volatile原理">9.2.4. volatile原理</h3>
<p>Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此<strong>不会将该变量上的操作与其他内存操作一起重排序</strong>。</p>
<p><strong>在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。</strong></p>
<p>当一个变量定义为 volatile 之后，将具备两种特性：</p>
<ul>
<li>
<p>保证此变量对所有的线程的可见性。</p>
</li>
<li>
<p>禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0， (%esp)”操作，这个操作相当于一个<strong>内存屏障</strong>（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障。</p>
</li>
<li>
<p>不保证变量的原子性</p>
</li>
</ul>
<p>volatile 性能：volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。</p>
<h3 id="9-2-5-Happen-Before（了解）">9.2.5. Happen-Before（了解）</h3>
<p>在常规的开发中，如果我们通过上述规则来分析一个并发程序是否安全，估计脑壳会很疼。因为更多时候，我们是分析一个并发程序是否安全，其实都依赖Happen-Before原则进行分析。Happen-Before被翻译成<strong>先行发生原则</strong>，意思就是<strong>当A操作先行发生于B操作，则在发生B操作的时候，操作A产生的影响能被B观察到</strong>，“影响”包括修改了内存中的共享变量的值、发送了消息、调用了方法等。</p>
<p>Happen-Before的规则有以下几条：</p>
<ol>
<li>程序次序规则（Program Order Rule）：在<strong>一个线程内</strong>一段代码的**执行结果是有序的。**就算还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变！</li>
<li>管程锁定规则（Monitor Lock Rule）：就是无论是在单线程环境还是多线程环境，对于<strong>同一个锁</strong>来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果！(管程是一种通用的同步原语，synchronized就是管程的实现）</li>
<li>volatile变量规则（volatile Variable Rule）：<strong>对同一个volatile的变量，先行发生的写操作，肯定早于后续发生的读操作</strong></li>
<li>线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作</li>
<li>线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。</li>
<li>线程中断规则（Thread Interruption Rule）：对线程的interruption()调用，先于被调用的线程检测中断事件(Thread.interrupted())的发生</li>
<li>对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</li>
<li>传递性（Transitivity）：如果操作A先于操作B、操作B先于操作C，则操作A先于操作C</li>
</ol>
<p>以上这些规则保障了happen-before的顺序，如果不符合以上规则，那么在多线程环境下就不能<strong>保证执行顺序等同于代码顺序</strong>。通过这些条件的判定，仍然很难判断一个线程是否能安全执行，线程安全多数依赖于工具类的安全性来保证。想提高自己对线程是否安全的判断能力，必然需要理解所使用的框架或者工具的实现，并积累线程安全的经验。</p>
<h2 id="9-3-CAS">9.3. CAS</h2>
<p>CAS：Compare and Swap。比较并交换的意思。CAS操作有3个基本参数：内存地址A，旧值B，新值C。它的作用是将指定内存地址A的内容与所给的旧值B相比，如果相等，则将其内容替换为指令中提供的新值C；如果不等，则更新失败。类似于修改登陆密码的过程。当用户输入的原密码和数据库中存储的原密码相同，才可以将原密码更新为新密码，否则就不能更新。</p>
<p>**CAS是解决多线程并发安全问题的一种乐观锁算法。**因为它在对共享变量更新之前，会先比较当前值是否与更新前的值一致，如果一致则更新，如果不一致则循环执行（称为自旋锁），直到当前值与更新前的值一致为止，才执行更新。</p>
<p>Unsafe类是CAS的核心类，提供<strong>硬件级别的原子操作</strong>（目前所有CPU基本都支持硬件级别的CAS操作）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象、对象的属性地址偏移量、预期值、修改值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object var1， <span class="type">long</span> var2， <span class="type">int</span> var4， <span class="type">int</span> var5)</span>;</span><br></pre></td></tr></table></figure>
<p>Unsafe简单demo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException， IllegalAccessException &#123;</span><br><span class="line">        <span class="type">UnsafeDemo</span> <span class="variable">unsafeDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnsafeDemo</span>();</span><br><span class="line">        System.out.println(unsafeDemo.number);<span class="comment">// 修改前</span></span><br><span class="line">        unsafeDemo.compareAndSwap(<span class="number">0</span>， <span class="number">30</span>);</span><br><span class="line">        System.out.println(unsafeDemo.number);<span class="comment">// 修改后</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compareAndSwap</span><span class="params">(<span class="type">int</span> oldValue， <span class="type">int</span> newValue)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过反射获取Unsafe类中的theUnsafe对象</span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="literal">true</span>); <span class="comment">// 设置为可见</span></span><br><span class="line">            <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) theUnsafe.get(<span class="literal">null</span>); <span class="comment">// 获取Unsafe对象</span></span><br><span class="line">            <span class="comment">// 获取number的偏移量</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> unsafe.objectFieldOffset(UnsafeDemo.class.getDeclaredField(<span class="string">&quot;number&quot;</span>));</span><br><span class="line">            <span class="comment">// cas操作</span></span><br><span class="line">            unsafe.compareAndSwapInt(<span class="built_in">this</span>， offset， oldValue， newValue);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-1-基本代码演示">9.3.1. 基本代码演示</h3>
<p>在JUC下有个atomic包，有很多原子操作的包装类：</p>
<p><img src="1595168900123.png" alt="1595168900123"></p>
<p>这里以AtomicInteger这个类来演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CasDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次更新：&quot;</span> + i.compareAndSet(<span class="number">1</span>， <span class="number">200</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次更新后i的值：&quot;</span> + i.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;第二次更新：&quot;</span> + i.compareAndSet(<span class="number">1</span>， <span class="number">300</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;第二次更新后i的值：&quot;</span> + i.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;第三次更新：&quot;</span> + i.compareAndSet(<span class="number">200</span>， <span class="number">300</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;第三次更新后i的值：&quot;</span> + i.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第一次更新：true</span><br><span class="line">第一次更新后i的值：200</span><br><span class="line">第二次更新：false</span><br><span class="line">第二次更新后i的值：200</span><br><span class="line">第三次更新：true</span><br><span class="line">第三次更新后i的值：300</span><br></pre></td></tr></table></figure>
<p>结果分析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一次更新：i的值（1）和预期值（1）相同，所以执行了更新操作，把i的值更新为200</span><br><span class="line">第二次更新：i的值（200）和预期值（1）不同，所以不再执行更新操作</span><br><span class="line">第三次更新：i的值（200）和预期值（1）相同，所以执行了更新操作，把i的值更新为300</span><br></pre></td></tr></table></figure>
<h3 id="9-3-2-验证原子性">9.3.2. 验证原子性</h3>
<p>还是改造之前的验证volatile关键字的案例如下：</p>
<p><img src="1595170303332.png" alt="1595170303332"></p>
<p>测试结果如下：</p>
<p><img src="1595170398079.png" alt="1595170398079"></p>
<p>也很完美！</p>
<h3 id="9-3-3-缺点">9.3.3. 缺点</h3>
<p><strong>开销大</strong>：在并发量比较高的情况下，如果反复尝试更新某个变量，却又一直更新不成功，会给CPU带来较大的压力。可以用LongAdder代替。</p>
<p><strong>ABA问题</strong>：当变量从A修改为B再修改回A时，变量值等于期望值A，但是无法判断是否修改，CAS操作在ABA修改后依然成功。</p>
<p><strong>不能保证代码块的原子性</strong>：CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。</p>
<h3 id="9-3-4-原子类应用">9.3.4 原子类应用</h3>
<h4 id="ABA问题解决"><strong>ABA问题解决</strong></h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; stampedReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">100</span>， <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">stampedReference.compareAndSet(<span class="number">100</span>， <span class="number">101</span>， stampedReference.getStamp()， stampedReference.getStamp() + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h4 id="手搓自旋锁"><strong>手搓自旋锁</strong></h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    thread = Thread.currentThread();</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;coming.....&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="literal">null</span>， thread)) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;over.....&quot;</span>);</span><br><span class="line">    atomicReference.compareAndSet(thread， <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-5-LongAdder源码">9.3.5 LongAdder源码</h3>
<p><img src="20210406180311322.png" alt="20210406180311322.png"></p>
<h4 id="热点分散">热点分散</h4>
<p>多个线程需要同时对value进行操作时候，可以对线程id进行hash得到hash值，再根据hash值映射到这个数组cells的某个下标，再对该下标所对应的值进行自增操作。</p>
<p><img src="20210406182256927.png" alt="20210406182256927.png"></p>
<h4 id="父类Striped64-部分成员变量">父类Striped64 部分成员变量</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CPU数量，即Cells数组的最大长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"><span class="comment">//存放Cell的hash表，大小为2的幂</span></span><br><span class="line"><span class="comment">//这里的Cell是Striped64的内部类</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.在开始没有竞争的情况下，将累加值累加到base；</span></span><br><span class="line"><span class="comment">2.在cells初始化的过程中，cells处于不可用的状态，这时候也会尝试将通过cas操作值累加到base</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> base;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cellsBusy，它有两个值0或1，它的作用是当要修改cells数组时加锁，</span></span><br><span class="line"><span class="comment">防止多线程同时修改cells数组(也称cells表)，0为无锁，1位加锁，加锁的状况有三种:</span></span><br><span class="line"><span class="comment">(1). cells数组初始化的时候；</span></span><br><span class="line"><span class="comment">(2). cells数组扩容的时候；</span></span><br><span class="line"><span class="comment">(3).如果cells数组中某个元素为null，给这个位置创建新的Cell对象的时候；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;	</span><br></pre></td></tr></table></figure>
<p>内部是一个Base+一个Cell[ ]数组 。sum( )会将所有cell数组中的value和base累加作为返回值，核心的思想就是将之前AtomicLong一个value的更新压力分散到多个value中去，从而降级更新热点 。</p>
<h2 id="9-4-AQS">9.4. AQS</h2>
<p>AbstractQueuedSynchronizer抽象队列同步器简称AQS，它是实现同步器的基础组件（框架），juc下面Lock（ReentrantLock、ReentrantReadWriteLock等）的实现以及一些并发工具类（Semaphore、CountDownLatch、CyclicBarrier等）就是通过AQS来实现的。具体用法是通过继承AQS实现其模板方法，然后将子类作为同步组件的内部类。</p>
<p>But</p>
<p>StampLock不是基于AQS实现的。</p>
<p>加锁会导致阻塞，有阻塞就需要排队，实现排队必然需要队列。如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中，这个队列就是AQS的抽象表现。</p>
<p>核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果 被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 <strong>CLH 队列锁</strong> 实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<p>CLH（Craig，Landin and Hagersten），是一种基于链表的可扩展、高性能、公平的自旋锁。</p>
<p><img src="20201024104940778.png" alt="20201024104940778.png"></p>
<p>AB两个线程进来了以后，总共有3个Node节点，其中队列的第一个是傀儡节点(哨兵节点) 。哨兵节点并不存储任何信息，只是占位。</p>
<p>内部类Node的成员变量：</p>
<p><img src="20210702094553986.png" alt="20210702094553986.png"></p>
<h3 id="9-4-1-框架结构">9.4.1. 框架结构</h3>
<p>AQS框架结构如下：</p>
<p><img src="CLH.png" alt="img"></p>
<p>AQS维护了一个volatile语义(支持多线程下的可见性)的共享资源变量<strong>state</strong>和一个FIFO（first-in-first-out）<strong>线程等待队列</strong>(多线程竞争state资源被阻塞时，会进入此队列)。</p>
<h3 id="9-4-2-基于AQS实现锁的思路">9.4.2. 基于AQS实现锁的思路</h3>
<p>AQS将大部分的同步逻辑均已经实现好，继承的自定义同步器只需要实现state的获取(acquire)和释放(release)的逻辑代码就可以，主要包括下面方法：</p>
<ul>
<li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li>
<li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li>
<li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>
<li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>
</ul>
<p>也就是说：通过AQS可以实现独占锁（只有一个线程可以获取到锁，如：ReentrantLock），也可以实现共享锁（多个线程都可以获取到锁Semaphore/CountDownLatch等）</p>
<h3 id="9-4-3-基于AQS实现独占锁">9.4.3. 基于AQS实现独占锁</h3>
<p>jdk官方文档给出了使用案例：</p>
<p><img src="1595502744412.png" alt="1595502744412"></p>
<p>把jdk文档中的案例copy到我们工程中：</p>
<p><img src="1595506276170.png" alt="1595506276170"></p>
<p>就可以直接使用了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AqsDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">DataThree</span> <span class="variable">dataThree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataThree</span>();</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                dataThree.incr();</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;， <span class="string">&quot;&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(dataThree.getNum());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataThree</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> num;</span><br><span class="line">    <span class="type">Mutex</span> <span class="variable">mutex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mutex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span>&#123;</span><br><span class="line">        mutex.lock();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        mutex.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试效果如下：</p>
<p><img src="1595503660735.png" alt="1595503660735"></p>
<h3 id="9-4-4-ReentrantLock底层原理">9.4.4. ReentrantLock底层原理</h3>
<p>接下来就以ReetrantLock为例，说明AQS在锁底层的应用。</p>
<p><img src="1595507428796.png" alt="1595507428796"></p>
<p>在ReentrantLock类中包含了3个AQS的实现类：</p>
<ol>
<li>抽象类Sync</li>
<li>非公平锁实现类NonfaireSync，会直接使用 CAS 进行抢占，修改变量 state 值。如果成功则直接把自己的线程设置到 exclusiveOwnerThread，也就是获得锁成功。</li>
<li>公平锁实现类FairSync，不会进行抢占，而是规规矩矩的进行排队。<em>老实人</em></li>
</ol>
<p>在ReetrantLock的源码中可以发现：</p>
<p><img src="1595508265596.png" alt="1595508265596"></p>
<p><img src="20230208105632.png" alt="20230208105632"></p>
<h4 id="9-4-4-1-Sync抽象类">9.4.4.1. Sync抽象类</h4>
<p>内部方法主要包括：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义方法：为非公平锁的实现提供快捷路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义通用方法，两个子类的tryAcquire方法都需要使用非公平的trylock方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 如果当前没有线程获取到锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>， acquires)) &#123; <span class="comment">// 则CAS获取锁</span></span><br><span class="line">            setExclusiveOwnerThread(current); <span class="comment">// 如果获取锁成功，把当前线程设置为有锁线程</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// 如果当前线程已经拥有锁，则重入</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires; <span class="comment">// 每重入一次stat累加acquires</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现AQS的释放锁方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases; <span class="comment">// 每释放一次stat就减releases</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread()) <span class="comment">// 当前线程不是有锁线程抛异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// stat减为0则释放锁</span></span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// While we must in general read state before owner，</span></span><br><span class="line">    <span class="comment">// we don&#x27;t need to do so to check if current thread is owner</span></span><br><span class="line">    <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-4-4-2-NonfairSync">9.4.4.2. NonfairSync</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sync object for non-fair locks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge， backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一个线程抢占</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>， <span class="number">1</span>)) <span class="comment">// CAS把stat设置为1</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread()); <span class="comment">// 获取到锁</span></span><br><span class="line">        <span class="comment">// 第二个线程以及后续线程抢占</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires); <span class="comment">// 使用了Sync抽象类的nonfairTryAcquire方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>acquire(1)方法是AQS自己实现的本质就是调用tryAcquire方法，如果tryAcquire获取到锁且无法进入等待队列，则中止线程。</p>
<ol>
<li><strong>tryAcquire</strong>，分别由继承 AQS 的公平锁（FairSync）、非公平锁（NonfairSync）实现。</li>
<li><strong>addWaiter</strong>，该方法是 AQS 的私有方法，主要用途是方法 <strong>tryAcquire</strong> 返回 false 以后，也就是获取锁失败以后，把当前请求锁的线程添加到队列中，并返回 Node 节点。</li>
<li><strong>acquireQueued</strong>，负责把 addWaiter 返回的 Node 节点添加到队列结尾，并会执行获取锁操作以及判断是否把当前线程挂起。</li>
<li><strong>selfInterrupt</strong>，是 AQS 中的 <code>Thread.currentThread().interrupt()</code> 方法调用，它的主要作用是在执行完 acquire 之前自己执行中断操作。</li>
</ol>
<p><img src="1595508846363.png" alt="1595508846363"></p>
<p>B线程开始抢占，走tryAcquire即nonfairTryAcquire方法，如果返回false，则继续往下走addWaiter。</p>
<p><img src="20201025202052403.png" alt="20201025202052403.png"></p>
<p>当执行方法 <code>addWaiter</code>，那么就是 <code>!tryAcquire = true</code>，也就是 tryAcquire 获取锁失败了。接下来就是把当前线程封装到 Node 节点中，加入到 FIFO 队列中。<em>因为先进先出，所以后来的队列加入到队尾</em>。</p>
<p>A线程长期占锁，B线程会先enq完成虚拟节点和B结点的创建，之后的C、D、E节点不会走enq方法，因为pred != null了。</p>
<p><img src="20201025202813662.png" alt="20201025202813662.png"></p>
<p>下方先设置虚拟节点（哨兵节点），原来指向空的head和tail，都会指向虚拟节点。之后B线程形成的node节点的prev会指向虚拟节点，tail通过CAS从指向虚拟节点再到指向B节点，最后虚拟结点的next会指向B节点。</p>
<p><img src="20201025203416851.png" alt="20201025203416851.png"></p>
<p>addWaiter走完，走acquireQueued。</p>
<p>1、2步主要是把前置节点的waitStatus由0改为-1，并挂起自己，即LockSupport.park()。通俗来讲就是在队列里面坐稳，等待唤醒执行。第3步表示线程B或者C已经获取了permit了 。之前前置节点为head时才会进入第3步。</p>
<p><img src="20201028212208656.png" alt="20201028212208656.png"></p>
<p><img src="20201028220559370.png" alt="20201028220559370.png"></p>
<ol>
<li>如果前一个节点状态是 <code>SIGNAL</code>（当前节点的下一个节点状态已经被挂起），则返回 true。<em>安心睡觉😪等着被叫醒</em></li>
<li>如果前一个节点状态是 <code>CANCELLED</code>（取消排队，放弃获取锁），就是它放弃了，则继续向前寻找其他节点。</li>
<li>最后如果什么都没找到，就给前一个节点设置个闹钟 <code>SIGNAL</code>，等着被通知。</li>
</ol>
<p><img src="20201028213303522.png" alt="20201028213303522.png"></p>
<p><img src="20201028213629725.png" alt="20201028213629725.png"></p>
<p>unlock( )获取permit，permit包括三个方法：release | tryRelease | unparkSuccessor(h)</p>
<p>当A线程办理好业务，离开的时候，会把傀儡结点的waitStatus从-1改为0 | 将state从1改为0，将当前线程置为null</p>
<p><img src="20201028214828280.png" alt="20201028214828280.png"></p>
<p><img src="20201028213848283.png" alt="20201028213848283.png"></p>
<p><img src="20201028214637248.png" alt="20201028214637248.png"></p>
<p>如果B上位，首先将state从0改为1(表示占用)，把thread置为线程B | 会执行如下图的①②③④，会触发GC，然后就把第一个灰色的傀儡结点给清除掉了，这个时候原来的B结点重新成为傀儡结点</p>
<p><img src="20210706122007768.png" alt="20210706122007768.png"></p>
<h4 id="9-4-4-3-FairSync">9.4.4.3. FairSync</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sync object for fair locks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fair version of tryAcquire.  Don&#x27;t grant access unless</span></span><br><span class="line"><span class="comment">     * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;  <span class="comment">// 从线程有序等待队列中获取等待</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>， acquires)) &#123; </span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// 可重入</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hasQueuedPredecessors具体实现如下：</p>
<p><img src="1595510443214.png" alt="1595510443214"></p>
<ol>
<li>当等待队列只有一个线程时，直接获取到锁</li>
<li>如果队列不止一个线程，并且下一个线程就是当前申请锁的线程，则获取锁</li>
</ol>
<p><img src="20210705205335214.png" alt="20210705205335214.png"></p>
<p>公平锁与非公平锁的lock()方法唯一的区别 ：多了一个hasQueuedPredecessors() ，即判断等待队列中是否存在有效节点。</p>
<h2 id="9-5-各种锁">9.5. 各种锁</h2>
<p>synchronized：偏向锁（偏向第一个线程，效率最高） —&gt; 如果有线程竞争升级为轻量级锁（自旋锁） —&gt; 自旋10次升级为重量级锁（悲观锁）</p>
<h1>10. ThreadLocal</h1>
<p><img src="https://javaguide.cn/2.84686f10.png" alt="img"></p>
<p><code>ThreadLocalMap</code>有自己的独立实现，可以简单地将它的<code>key</code>视作<code>ThreadLocal</code>，<code>value</code>为代码中放入的值（实际上<code>key</code>并不是<code>ThreadLocal</code>本身，而是它的一个<strong>弱引用</strong>）</p>
<p>每个线程在往<code>ThreadLocal</code>里放值的时候，都会往自己的<code>ThreadLocalMap</code>里存，读也是以<code>ThreadLocal</code>作为引用，在自己的<code>map</code>里找对应的<code>key</code>，从而实现了<strong>线程隔离</strong></p>
<h2 id="内存泄漏">内存泄漏</h2>
<p>ThreadLocalMap中使用的key为ThreadLocal的弱引用，而value是强引用。所以，如果ThreadLocal没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而value不会被清理掉。这样一来，ThreadLocalMap 中就会出现key为null的Entry。</p>
<p>假如我们不做任何措施的话，value 永远无法被GC回收，这个时候就可能会产生内存泄露。<br>
ThreadLocalMap实现中已经考虑了这种情况，使用完ThreadLocal方法后最好手动调用remove()方法会清理掉key为null的记录。</p>
<h1>12.并发集合</h1>
<p>ConcurrentHashMap</p>
<ul>
<li>采用 CAS + Synchronized来保证并发安全进行实现CAS控制数组节点的添加</li>
<li>synchronized只锁定当前链表或红黑二叉树的首节点，只要hash不冲突，就不会产生并发的问题 , 效率得到提升</li>
</ul>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/java8_concurrenthashmap.png" alt="img"></p>
<h1>4. 并发容器类</h1>
<p>面试题：</p>
<p>​		请举例说明集合类是不安全的。</p>
<h2 id="4-1-重现线程不安全：List">4.1. 重现线程不安全：List</h2>
<p>首先以List作为演示对象，创建多个线程对List接口的常用实现类ArrayList进行add操作。</p>
<p><img src="F:/note/1%E7%A7%8B%E6%8B%9B/JUC%20%E8%AF%BE%E4%BB%B6/1562825303228.png" alt="1562825303228"></p>
<p>内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotSafeDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>， <span class="number">8</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;， String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<p><img src="F:/note/1%E7%A7%8B%E6%8B%9B/JUC%20%E8%AF%BE%E4%BB%B6/1562825565718.png" alt="1562825565718"></p>
<p><strong>出现了线程不安全错误</strong></p>
<p>ArrayList在多个线程同时对其进行修改的时候，就会抛出<strong>java.util.ConcurrentModificationException异常（并发修改异常）</strong>，因为ArrayList的add及其他方法都是线程不安全的，有源码佐证：</p>
<p><img src="F:/note/1%E7%A7%8B%E6%8B%9B/JUC%20%E8%AF%BE%E4%BB%B6/1562826214175.png" alt="1562826214175"></p>
<p>解决方案：</p>
<p>​		List接口有很多实现类，除了常用的ArrayList之外，还有Vector和SynchronizedList。</p>
<p><img src="F:/note/1%E7%A7%8B%E6%8B%9B/JUC%20%E8%AF%BE%E4%BB%B6/1562826331284.png" alt="1562826331284"></p>
<p>他们都有synchronized关键字，说明都是线程安全的。</p>
<p><img src="F:/note/1%E7%A7%8B%E6%8B%9B/JUC%20%E8%AF%BE%E4%BB%B6/1562826499790.png" alt="1562826499790"></p>
<p>改用Vector或者synchronizedList试试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//List&lt;String&gt; list = new Vector&lt;&gt;();</span></span><br><span class="line">    List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>， <span class="number">8</span>));</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125;， String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即可解决！</p>
<p>Vector和Synchronized的缺点：</p>
<p>​		vector：<strong>内存消耗比较大</strong>，适合一次增量比较大的情况</p>
<p>​		SynchronizedList：<strong>迭代器涉及的代码没有加上线程同步代码</strong></p>
<h2 id="4-2-CopyOnWrite容器">4.2. CopyOnWrite容器</h2>
<p>什么是CopyOnWrite容器</p>
<p>​		<strong>CopyOnWrite容器</strong>（简称COW容器）即<strong>写时复制</strong>的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以<strong>CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器</strong>。</p>
<p>​		从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器，它们是CopyOnWriteArrayList和CopyOnWriteArraySet。</p>
<p>先看看CopyOnWriteArrayList类：发现它的本质就是数组</p>
<p><img src="F:/note/1%E7%A7%8B%E6%8B%9B/JUC%20%E8%AF%BE%E4%BB%B6/1562830411166.png" alt="1562830411166"></p>
<p>再来看看CopyOnWriteArrayList的add方法：发现该方法是线程安全的</p>
<p><img src="F:/note/1%E7%A7%8B%E6%8B%9B/JUC%20%E8%AF%BE%E4%BB%B6/1562829359583.png" alt="1562829359583"></p>
<p>使用CopyOnWriteArrayList改造main方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//List&lt;String&gt; list = new Vector&lt;&gt;();</span></span><br><span class="line">    <span class="comment">//List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>， <span class="number">8</span>));</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125;， String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CopyOnWrite并发容器用于读多写少的并发场景</strong>。比如：白名单，黑名单。假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单一定周期才会更新一次。</p>
<p>缺点：</p>
<ol>
<li>**内存占用问题。**写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存。通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。</li>
<li>**数据一致性问题。**CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</li>
</ol>
<h2 id="4-3-扩展类比：Set和Map">4.3. 扩展类比：Set和Map</h2>
<p>HashSet和HashMap也都是线程不安全的，类似于ArrayList，也可以通过代码证明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">notSafeMap</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String， String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            map.put(String.valueOf(Thread.currentThread().getName())， UUID.randomUUID().toString().substring(<span class="number">0</span>， <span class="number">8</span>));</span><br><span class="line">            System.out.println(map);</span><br><span class="line">        &#125;， String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">notSafeSet</span><span class="params">()</span> &#123;</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            set.add(UUID.randomUUID().toString().substring(<span class="number">0</span>， <span class="number">8</span>));</span><br><span class="line">            System.out.println(set);</span><br><span class="line">        &#125;， String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>都会报：ConcurrentModificationException异常信息。</p>
<p>Collections提供了方法synchronizedList保证list是同步线程安全的，Set和Map呢？</p>
<p><img src="F:/note/1%E7%A7%8B%E6%8B%9B/JUC%20%E8%AF%BE%E4%BB%B6/1562828426062.png" alt="1562828426062"></p>
<p>JUC提供的CopyOnWrite容器实现类有：CopyOnWriteArrayList和CopyOnWriteArraySet。</p>
<p>有没有Map的实现：</p>
<p><img src="F:/note/1%E7%A7%8B%E6%8B%9B/JUC%20%E8%AF%BE%E4%BB%B6/1562831562414.png" alt="1562831562414"></p>
<p>最终实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotSafeDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        notSafeList();</span><br><span class="line">        notSafeSet();</span><br><span class="line">        notSafeMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">notSafeMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//Map&lt;String， String&gt; map = new HashMap&lt;&gt;();</span></span><br><span class="line">        <span class="comment">//Map&lt;String， String&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());</span></span><br><span class="line">        Map&lt;String， String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                map.put(String.valueOf(Thread.currentThread().getName())， UUID.randomUUID().toString().substring(<span class="number">0</span>， <span class="number">8</span>));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;， String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">notSafeSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//Set&lt;String&gt; set = new HashSet&lt;&gt;();</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                set.add(UUID.randomUUID().toString().substring(<span class="number">0</span>， <span class="number">8</span>));</span><br><span class="line">                System.out.println(set);</span><br><span class="line">            &#125;， String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">notSafeList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//List&lt;String&gt; list = new Vector&lt;&gt;();</span></span><br><span class="line">        <span class="comment">//List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>， <span class="number">8</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;， String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩展：HashSet底层数据结构是什么？HashMap  ?</p>
<p>​			但HashSet的add是放一个值，而HashMap是放K、V键值对</p>
<p><img src="F:/note/1%E7%A7%8B%E6%8B%9B/JUC%20%E8%AF%BE%E4%BB%B6/1562830638509.png" alt="1562830638509"></p>
<p><img src="F:/note/1%E7%A7%8B%E6%8B%9B/JUC%20%E8%AF%BE%E4%BB%B6/1562830863791.png" alt="1562830863791"></p>
<h1>5. JUC强大的辅助类</h1>
<p>JUC的多线程辅助类非常多，这里我们介绍三个：</p>
<ol>
<li>CountDownLatch（倒计数器）</li>
<li>CyclicBarrier（循环栅栏）</li>
<li>Semaphore（信号量）</li>
</ol>
<p><img src="F:/note/1%E7%A7%8B%E6%8B%9B/JUC%20%E8%AF%BE%E4%BB%B6/1562913111979.png" alt="1562913111979"></p>
<h2 id="5-1-CountDownLatch">5.1. CountDownLatch</h2>
<p>CountDownLatch是一个非常实用的多线程控制工具类，应用非常广泛。</p>
<p>例如：在手机上安装一个应用程序，假如需要5个子进程检查服务授权，那么主进程会维护一个计数器，初始计数就是5。用户每同意一个授权该计数器减1，当计数减为0时，主进程才启动，否则就只有阻塞等待了。</p>
<p>CountDownLatch中count down是倒数的意思，latch则是门闩的含义。整体含义可以理解为倒数的门栓，似乎有一点“三二一，芝麻开门”的感觉。CountDownLatch的作用也是如此。</p>
<p>常用的就下面几个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="type">int</span> count) <span class="comment">//实例化一个倒计数器，count指定初始计数</span></span><br><span class="line">countDown() <span class="comment">// 每调用一次，计数减一</span></span><br><span class="line">await() <span class="comment">//等待，当计数减到0时，阻塞线程（可以是一个，也可以是多个）并行执行</span></span><br></pre></td></tr></table></figure>
<p>案例：6个同学陆续离开教室后值班同学才可以关门。</p>
<p><img src="F:/note/1%E7%A7%8B%E6%8B%9B/JUC%20%E8%AF%BE%E4%BB%B6/1562920244806.png" alt="1562920244806"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * main方法也是一个进程，在这里是主进程，即上锁的同学</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化计数器，初始计数为6</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 每个同学墨迹几秒钟</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">5</span>));</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 同学出门了&quot;</span>);</span><br><span class="line">                    <span class="comment">// 调用countDown()计算减1</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;， String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用计算器的await方法，等待6位同学都出来</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;值班同学锁门了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">同学3 出来了</span><br><span class="line">同学1 出来了</span><br><span class="line">同学0 出来了</span><br><span class="line">同学2 出来了</span><br><span class="line">同学5 出来了</span><br><span class="line">同学4 出来了</span><br><span class="line">值班同学锁门了</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>面试：CountDownLatch 与 join 方法的区别</p>
<p>​		调用一个子线程的 <strong>join()方法</strong>后，该线程会一直<strong>被阻塞直到该线程运行完毕</strong>。而 CountDownLatch 则使用计数器允许子线程<strong>运行完毕或者运行中</strong>时候递减计数，也就是 CountDownLatch 可以在子线程运行任何时候让 await 方法返回而不一定必须等到线程结束；另外使用线程池来管理线程时候一般都是直接添加 Runnable 到线程池这时候就没有办法在调用线程的 join 方法了，countDownLatch 相比 Join 方法让我们对线程同步有更灵活的控制。</p>
<p>练习：秦灭六国，一统华夏。（模仿课堂案例，练习枚举类的使用）</p>
<h2 id="5-2-CyclicBarrier">5.2. CyclicBarrier</h2>
<p>从字面上的意思可以知道，这个类的中文意思是“循环栅栏”。大概的意思就是一个可循环利用的屏障。该命令只在每个屏障点运行一次。若在所有参与线程之前更新共享状态，此屏障操作很有用</p>
<p>常用方法：</p>
<ol>
<li>CyclicBarrier(int parties， Runnable barrierAction) 创建一个CyclicBarrier实例，parties指定参与相互等待的线程数，<strong>barrierAction一个可选的Runnable命令，该命令只在每个屏障点运行一次，可以在执行后续业务之前共享状态。该操作由最后一个进入屏障点的线程执行。</strong></li>
<li>CyclicBarrier(int parties) 创建一个CyclicBarrier实例，parties指定参与相互等待的线程数。</li>
<li>await() 该方法被调用时表示当前线程已经到达屏障点，当前线程阻塞进入休眠状态，<strong>直到所有线程都到达屏障点</strong>，当前线程才会被唤醒。</li>
</ol>
<p>案例：组队打boss过关卡游戏。</p>
<p><img src="F:/note/1%E7%A7%8B%E6%8B%9B/JUC%20%E8%AF%BE%E4%BB%B6/1562925365024.png" alt="1562925365024"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>， () -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 过关了&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始第一关&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">4</span>));</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始打boss&quot;</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始第二关&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">4</span>));</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始打boss&quot;</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始第三关&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">4</span>));</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始打boss&quot;</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;， String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1 开始第一关</span><br><span class="line">2 开始第一关</span><br><span class="line">0 开始第一关</span><br><span class="line">0 开始打boss</span><br><span class="line">2 开始打boss</span><br><span class="line">1 开始打boss</span><br><span class="line">1 过关了</span><br><span class="line">0 开始第二关</span><br><span class="line">2 开始第二关</span><br><span class="line">1 开始第二关</span><br><span class="line">1 开始打boss</span><br><span class="line">0 开始打boss</span><br><span class="line">2 开始打boss</span><br><span class="line">2 过关了</span><br><span class="line">1 开始第三关</span><br><span class="line">2 开始第三关</span><br><span class="line">0 开始第三关</span><br><span class="line">1 开始打boss</span><br><span class="line">0 开始打boss</span><br><span class="line">2 开始打boss</span><br><span class="line">2 过关了</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意：所有的&quot;过关了&quot;都是由最后到达await方法的线程执行打印的</strong></p>
<p>面试：CyclicBarrier和CountDownLatch的区别？</p>
<p>​		CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置，可以使用多次，所以CyclicBarrier能够处理更为复杂的场景；CountDownLatch允许一个或多个线程<strong>等待一组事件的产生</strong>，而CyclicBarrier用于等待其他线程<strong>运行到栅栏位置</strong>。</p>
<h2 id="5-3-Semaphore">5.3. Semaphore</h2>
<p>Semaphore翻译成字面意思为 信号量，Semaphore可以控制同时访问的线程个数。非常适合需求量大，而资源又很紧张的情况。比如给定一个资源数目有限的资源池，假设资源数目为N，每一个线程均可获取一个资源，但是当资源分配完毕时，后来线程需要阻塞等待，直到前面已持有资源的线程释放资源之后才能继续。</p>
<p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> permits)</span> <span class="comment">// 构造方法，permits指资源数目（信号量）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException <span class="comment">// 占用资源，当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），要么一直等下去，直到有线程释放信号量，或超时。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> <span class="comment">// （释放）实际上会将信号量的值加1，然后唤醒等待的线程。</span></span><br></pre></td></tr></table></figure>
<p>信号量主要用于两个目的：</p>
<ol>
<li>多个共享资源的互斥使用。</li>
<li>用于并发线程数的控制。保护一个关键部分不要一次输入超过N个线程。</li>
</ol>
<p>案例：6辆车抢占3个车位</p>
<p><img src="F:/note/1%E7%A7%8B%E6%8B%9B/JUC%20%E8%AF%BE%E4%BB%B6/1562925723418.png" alt="1562925723418"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化信号量，3个车位</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6个线程，模拟6辆车</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 抢占一个停车位</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 抢到了一个停车位！！&quot;</span>);</span><br><span class="line">                    <span class="comment">// 停一会儿车</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>));</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 离开停车位！！&quot;</span>);</span><br><span class="line">                    <span class="comment">// 开走，释放一个停车位</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;， String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0 抢到了一个停车位！！</span><br><span class="line">1 抢到了一个停车位！！</span><br><span class="line">2 抢到了一个停车位！！</span><br><span class="line">1 离开停车位！！</span><br><span class="line">3 抢到了一个停车位！！</span><br><span class="line">2 离开停车位！！</span><br><span class="line">4 抢到了一个停车位！！</span><br><span class="line">0 离开停车位！！</span><br><span class="line">5 抢到了一个停车位！！</span><br><span class="line">5 离开停车位！！</span><br><span class="line">3 离开停车位！！</span><br><span class="line">4 离开停车位！！</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>6. Callable接口</h1>
<p><strong>Thread</strong>类、<strong>Runnable</strong>接口使得多线程编程简单直接。</p>
<p>​		但Thread类和Runnable接口都不允许声明检查型<strong>异常</strong>，也不能定义<strong>返回值</strong>。没有返回值这点稍微有点麻烦。不能声明抛出检查型异常则更麻烦一些。</p>
<p>​		**public void run()**方法规范意味着你必须捕获并处理检查型异常。即使你小心捕获异常，也不能保证这个类（Runnable对象）的所有使用者都读取异常信息。</p>
<p>​		以上两个问题现在都得到了解决。从java5开始，提供了Callable接口，是Runable接口的增强版。用Call()方法作为线程的执行体，增强了之前的run()方法。因为call方法可以有返回值，也可以声明抛出异常。</p>
<h2 id="6-1-Callable和Runable对比">6.1. Callable和Runable对比</h2>
<p>先初步认识一下Callable接口：</p>
<p><img src="F:/note/1%E7%A7%8B%E6%8B%9B/JUC%20%E8%AF%BE%E4%BB%B6/1562859167203.png" alt="1562859167203"></p>
<p>这是一个函数式接口，因此可以用作lambda表达式或方法引用的赋值对象。</p>
<p>具体代码实现对比：创建一个CallableDemo.java</p>
<p><img src="F:/note/1%E7%A7%8B%E6%8B%9B/JUC%20%E8%AF%BE%E4%BB%B6/1562859974320.png" alt="1562859974320"></p>
<p>内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnableThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallableThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建多线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该如何使用Callable创建Thread对象，如果使用Runnable是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建多线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnableThread</span>()， <span class="string">&quot;threadName&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在能不能直接把MyRunnableThread换成MyCallableThread。当然不行，thread的构造方法参数需要Runnable类型的数据模型，而MyCallableThread属于Callable类型的。</p>
<p>那么到底怎么使用Callable创建thread对象呢？</p>
<h2 id="6-2-Callable的使用">6.2. Callable的使用</h2>
<p>这里需要一个FutureTask，先认识该类，上源码：</p>
<p><img src="F:/note/1%E7%A7%8B%E6%8B%9B/JUC%20%E8%AF%BE%E4%BB%B6/1562861615527.png" alt="1562861615527"></p>
<p>发现：FutureTask其实可以充当了一个中间人的角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 创建Callable的实现类，并重写call()方法，该方法为线程执行体，并且该方法有返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallableThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException， InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 2. 创建Callable的实例，并用FutureTask类来包装Callable对象</span></span><br><span class="line">        <span class="comment">// 3. 创建FutureTask对象，需要一个Callable类型的参数</span></span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(<span class="keyword">new</span> <span class="title class_">MyCallableThread</span>());</span><br><span class="line">        <span class="comment">// 4. 创建多线程，由于FutureTask的本质是Runnable的实现类，所以第一个参数可以直接使用task</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task， <span class="string">&quot;threadName&quot;</span>).start();</span><br><span class="line">        <span class="comment">//new Thread(task， &quot;threadName2&quot;).start();</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">/*while (!task.isDone()) &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;wait...&quot;);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        System.out.println(task.get());</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; over!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FutureTask：未来的任务，用它就干一件事，<strong>异步调用。通常用它解决耗时任务，挂起堵塞问题。</strong></p>
<p>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给Future对象在后台完成，当主线程将来需要时，就可以通过Future对象获得后台作业的计算结果或者执行状态。</p>
<p>一般FutureTask多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。</p>
<p>FutureTask仅在call方法完成时才能get结果；如果计算尚未完成，则阻塞 get 方法。</p>
<p>一旦计算完成，就不能再重新开始或取消计算。get方法获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常。</p>
<p><strong>注意：</strong></p>
<ol>
<li><strong>为了防止主线程阻塞，建议get方法放到最后</strong></li>
<li><strong>只计算一次</strong>，FutureTask会复用之前计算过得结果</li>
</ol>
<p>创建多个线程，会怎样？</p>
<p><img src="F:/note/1%E7%A7%8B%E6%8B%9B/JUC%20%E8%AF%BE%E4%BB%B6/1562862680071.png" alt="1562862680071"></p>
<p>运行结果：依然只有一个就是threadName。</p>
<p>如果想打印threadName2的结果，即<strong>不想复用之前的计算结果。怎么办？再创建一个FutureTask对象即可。</strong></p>
<h2 id="6-3-面试题">6.3. 面试题</h2>
<p><strong>面试题：callable接口与runnable接口的区别？</strong></p>
<p>相同点：<strong>都是接口，都可以编写多线程程序，都采用Thread.start()启动线程</strong></p>
<p>不同点：</p>
<ol>
<li>具体方法不同：一个是run，一个是call</li>
<li>Runnable没有<strong>返回值</strong>；Callable可以返回执行结果，是个泛型</li>
<li>Callable接口的call()方法允许抛出<strong>异常</strong>；Runnable的run()方法异常只能在内部消化，不能往上继续抛</li>
<li>它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。</li>
</ol>
<p>面试题：获得多线程的方法几种？</p>
<p>​		（1）继承thread类（2）runnable接口</p>
<p>​		如果只回答这两个你连被问到juc的机会都没有</p>
<p>正确答案如下：</p>
<p>​		传统的是继承thread类和实现runnable接口</p>
<p>​		java5以后又有实现callable接口和java的线程池获得</p>
<h1>7. 阻塞队列（BlockingQueue）</h1>
<p>栈与队列简单回顾：</p>
<p>栈：先进后出，后进先出</p>
<p>队列：先进先出</p>
<h2 id="7-1-什么是BlockingQueue">7.1. 什么是BlockingQueue</h2>
<p>在多线程领域：所谓<strong>阻塞</strong>，在某些情况下会<strong>挂起线程</strong>（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起</p>
<p>BlockingQueue即阻塞队列，是java.util.concurrent下的一个接口，因此不难理解，BlockingQueue是为了解决多线程中数据高效安全传输而提出的。从阻塞这个词可以看出，在某些情况下对阻塞队列的访问可能会造成阻塞。被阻塞的情况主要有如下两种：</p>
<ol>
<li><strong>当队列满了的时候进行入队列操作</strong></li>
<li><strong>当队列空了的时候进行出队列操作</strong></li>
</ol>
<p>因此，当一个线程试图对一个已经满了的队列进行入队列操作时，它将会被阻塞，除非有另一个线程做了出队列操作；同样，当一个线程试图对一个空队列进行出队列操作时，它将会被阻塞，除非有另一个线程进行了入队列操作。</p>
<p><strong>阻塞队列主要用在生产者/消费者的场景</strong>，下面这幅图展示了一个线程生产、一个线程消费的场景：</p>
<p><img src="F:/note/1%E7%A7%8B%E6%8B%9B/JUC%20%E8%AF%BE%E4%BB%B6/1562942021825.png" alt="1562942021825"></p>
<p><strong>为什么需要BlockingQueue</strong><br>
好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了。在concurrent包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。</p>
<h2 id="7-2-认识BlockingQueue">7.2. 认识BlockingQueue</h2>
<p>java.util.concurrent 包里的 BlockingQueue是一个接口，继承Queue接口，Queue接口继承 Collection。</p>
<p><img src="F:/note/1%E7%A7%8B%E6%8B%9B/JUC%20%E8%AF%BE%E4%BB%B6/1562943086619.png" alt="1562943086619"></p>
<p>BlockingQueue接口主要有以下7个实现类：</p>
<ol>
<li><font color="red">ArrayBlockingQueue：由数组结构组成的有界阻塞队列。</font></li>
<li><font color="red">LinkedBlockingQueue：由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列。</font></li>
<li>PriorityBlockingQueue：支持优先级排序的无界阻塞队列。</li>
<li>DelayQueue：使用优先级队列实现的延迟无界阻塞队列。</li>
<li><font color="red">SynchronousQueue：不存储元素的阻塞队列，也即单个元素的队列。</font></li>
<li>LinkedTransferQueue：由链表组成的无界阻塞队列。</li>
<li>LinkedBlockingDeque：由链表组成的双向阻塞队列。</li>
</ol>
<p>BlockingQueue接口有以下几个方法：</p>
<p><img src="F:/note/1%E7%A7%8B%E6%8B%9B/JUC%20%E8%AF%BE%E4%BB%B6/1562943531362.png" alt="1562943531362"></p>
<p>它的方法可以分成以下4类：</p>
<table>
<thead>
<tr>
<th></th>
<th>抛出异常</th>
<th>特殊值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>插入</strong></td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e, time, unit)</td>
</tr>
<tr>
<td><strong>移除</strong></td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time, unit)</td>
</tr>
<tr>
<td><strong>检查</strong></td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody>
</table>
<p><strong>抛出异常</strong></p>
<p>​		add正常执行返回true，element（不删除）和remove返回阻塞队列中的第一个元素<br>
​		当阻塞队列满时，再往队列里add插入元素会抛IllegalStateException:Queue full<br>
​		当阻塞队列空时，再往队列里remove移除元素会抛NoSuchElementException<br>
​		当阻塞队列空时，再调用element检查元素会抛出NoSuchElementException</p>
<p><strong>特定值</strong><br>
插入方法，成功ture失败false<br>
移除方法，成功返回出队列的元素，队列里没有就返回null<br>
检查方法，成功返回队列中的元素，没有返回null</p>
<p><strong>一直阻塞</strong></p>
<p>​		如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。<br>
​		当阻塞队列满时，再往队列里put元素，队列会一直阻塞生产者线程直到put数据or响应中断退出<br>
​		当阻塞队列空时，再从队列里take元素，队列会一直阻塞消费者线程直到队列可用</p>
<p><strong>超时退出</strong></p>
<p>​		如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。<br>
​		返回一个特定值以告知该操作是否成功(典型的是 true / false)。</p>
<h2 id="7-3-代码演示">7.3. 代码演示</h2>
<p>创建BlockingQueueDemo类：</p>
<p><img src="F:/note/1%E7%A7%8B%E6%8B%9B/JUC%20%E8%AF%BE%E4%BB%B6/1562944351608.png" alt="1562944351608"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 第一组方法：add remove element</span></span><br><span class="line"><span class="comment">//        System.out.println(queue.add(&quot;a&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(queue.add(&quot;b&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(queue.add(&quot;c&quot;));</span></span><br><span class="line"><span class="comment">//        // System.out.println(queue.add(&quot;d&quot;));</span></span><br><span class="line"><span class="comment">//        // System.out.println(queue.element());</span></span><br><span class="line"><span class="comment">//        System.out.println(queue.remove());</span></span><br><span class="line"><span class="comment">//        System.out.println(queue.remove());</span></span><br><span class="line"><span class="comment">//        System.out.println(queue.remove());</span></span><br><span class="line"><span class="comment">//        //System.out.println(queue.remove());</span></span><br><span class="line"><span class="comment">//        //System.out.println(queue.element());</span></span><br><span class="line">        <span class="comment">// 第二组：offer poll peek</span></span><br><span class="line"><span class="comment">//        System.out.println(queue.offer(&quot;a&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(queue.offer(&quot;b&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(queue.offer(&quot;c&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(queue.offer(&quot;d&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(queue.peek());</span></span><br><span class="line"><span class="comment">//        System.out.println(queue.poll());</span></span><br><span class="line"><span class="comment">//        System.out.println(queue.poll());</span></span><br><span class="line"><span class="comment">//        System.out.println(queue.poll());</span></span><br><span class="line"><span class="comment">//        System.out.println(queue.poll());</span></span><br><span class="line"><span class="comment">//        System.out.println(queue.peek());</span></span><br><span class="line">        <span class="comment">// 第三组：put take</span></span><br><span class="line"><span class="comment">//        queue.put(&quot;a&quot;);</span></span><br><span class="line"><span class="comment">//        queue.put(&quot;b&quot;);</span></span><br><span class="line"><span class="comment">//        queue.put(&quot;c&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(queue.take());</span></span><br><span class="line"><span class="comment">//        queue.put(&quot;d&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(queue.take());</span></span><br><span class="line"><span class="comment">//        System.out.println(queue.take());</span></span><br><span class="line"><span class="comment">//        System.out.println(queue.take());</span></span><br><span class="line">        <span class="comment">// 第四组：offer poll</span></span><br><span class="line">        System.out.println(queue.offer(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        System.out.println(queue.offer(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">        System.out.println(queue.offer(<span class="string">&quot;c&quot;</span>));</span><br><span class="line">        System.out.println(queue.offer(<span class="string">&quot;d&quot;</span>， <span class="number">5</span>， TimeUnit.SECONDS));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">pengchang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/31/assets/">http://example.com/2023/03/31/assets/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">PC</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/5-%E8%AF%B7%E6%B1%82%E5%BA%94%E7%AD%94.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/11/redis%E6%89%8B%E6%90%93/"><img class="prev-cover" src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/5-%E8%AF%B7%E6%B1%82%E5%BA%94%E7%AD%94.png" onerror="onerror=null;src='https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/5-%E8%AF%B7%E6%B1%82%E5%BA%94%E7%AD%94.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">redis浅析</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/31/docker/"><img class="next-cover" src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/5-%E8%AF%B7%E6%B1%82%E5%BA%94%E7%AD%94.png" onerror="onerror=null;src='https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/5-%E8%AF%B7%E6%B1%82%E5%BA%94%E7%AD%94.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">docker</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2592/202208241424400.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">pengchang</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/pcpengchang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/pcpengchang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1767191006@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">1. JUC概述及回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-JUC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">1.1. JUC是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">1.2. 进程和线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91"><span class="toc-number">1.3.</span> <span class="toc-text">1.3. 并行和并发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-wait-sleep%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.</span> <span class="toc-text">1.4. wait&#x2F;sleep的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%9B%9E%E9%A1%BE"><span class="toc-number">1.5.</span> <span class="toc-text">1.5. 创建线程回顾</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.6.</span> <span class="toc-text">1.6. lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-1-%E4%BB%80%E4%B9%88%E6%98%AFlambda"><span class="toc-number">1.6.1.</span> <span class="toc-text">1.6.1. 什么是lambda</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-2-%E6%A1%88%E4%BE%8B"><span class="toc-number">1.6.2.</span> <span class="toc-text">1.6.2. 案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-3-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.6.3.</span> <span class="toc-text">1.6.3. 函数式接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-4-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.6.4.</span> <span class="toc-text">1.6.4. 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-synchronized%E5%9B%9E%E9%A1%BE"><span class="toc-number">1.7.</span> <span class="toc-text">1.7. synchronized回顾</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-synchronized%E7%9A%848%E9%94%81%E9%97%AE%E9%A2%98"><span class="toc-number">1.8.</span> <span class="toc-text">1.8. synchronized的8锁问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-1-%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.8.1.</span> <span class="toc-text">1.8.1 字节码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-2-synchronized%E9%94%81%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.8.2.</span> <span class="toc-text">1.8.2  synchronized锁的是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-3-%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">1.8.3.</span> <span class="toc-text">1.8.3 四大特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-synchronized-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.9.</span> <span class="toc-text">1.9 synchronized 性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">1.9.1.</span> <span class="toc-text">偏向锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E9%94%81"><span class="toc-number">1.9.2.</span> <span class="toc-text">轻量锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E8%86%A8%E8%83%80-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">1.9.3.</span> <span class="toc-text">锁膨胀-&gt;重量级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E9%94%80%E9%99%A4"><span class="toc-number">1.9.4.</span> <span class="toc-text">锁销除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%B2%97%E5%8C%96"><span class="toc-number">1.9.5.</span> <span class="toc-text">锁粗化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E5%9B%BE%E6%80%BB%E7%BB%93"><span class="toc-number">1.10.</span> <span class="toc-text">大图总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">2. Lock锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-ReentrantLock%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">2.1.</span> <span class="toc-text">2.1. ReentrantLock可重入锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E6%B5%8B%E8%AF%95%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1. 测试可重入性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E6%B5%8B%E8%AF%95%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2. 测试公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E9%99%90%E6%97%B6%E7%AD%89%E5%BE%85"><span class="toc-number">2.1.3.</span> <span class="toc-text">2.1.3. 限时等待</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-ReentrantLock%E5%92%8Csynchronized%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.4.</span> <span class="toc-text">2.1.4. ReentrantLock和synchronized区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-ReentrantReadWriteLock%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">2.2.</span> <span class="toc-text">2.2. ReentrantReadWriteLock读写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E9%87%8D%E5%86%99%E8%AF%BB%E5%86%99%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1. 重写读写问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2. 读写锁的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E9%94%81%E9%99%8D%E7%BA%A7"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.2.3. 锁降级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-%E8%AF%BB%E5%86%99%E9%94%81%E6%80%BB%E7%BB%93"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.2.4. 读写锁总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">3. 线程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%9B%9E%E9%A1%BE%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">3.1.</span> <span class="toc-text">3.1. 回顾线程通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92"><span class="toc-number">3.2.</span> <span class="toc-text">3.2. 虚假唤醒</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88Condition%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">3.3. 线程通信（Condition）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%AE%9A%E5%88%B6%E5%8C%96%E8%B0%83%E7%94%A8%E9%80%9A%E4%BF%A1"><span class="toc-number">3.4.</span> <span class="toc-text">3.4. 定制化调用通信</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">8. ThreadPool线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E6%9E%B6%E6%9E%84%E8%AF%B4%E6%98%8E"><span class="toc-number">4.1.</span> <span class="toc-text">8.1. 架构说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-Executors%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">4.2.</span> <span class="toc-text">8.2. Executors工具类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">4.3.</span> <span class="toc-text">8.3. 底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%847%E4%B8%AA%E9%87%8D%E8%A6%81%E5%8F%82%E6%95%B0"><span class="toc-number">4.3.1.</span> <span class="toc-text">8.3.1. 线程池的7个重要参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-2-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%95%E5%B1%82%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">4.3.2.</span> <span class="toc-text">8.3.2. 线程池底层工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-3-%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-number">4.3.3.</span> <span class="toc-text">8.3.3. 拒绝策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">4.4.</span> <span class="toc-text">8.4. 自定义线程池</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">9. 多线程高并发底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88JMM%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">9.1. java内存模型（JMM）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">5.2.</span> <span class="toc-text">9.2. volatile关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-1-%E9%AA%8C%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">5.2.1.</span> <span class="toc-text">9.2.1. 验证可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-2-%E9%AA%8C%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">5.2.2.</span> <span class="toc-text">9.2.2. 验证有序性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-3-%E9%AA%8C%E8%AF%81%E4%B8%8D%E5%85%B7%E5%A4%87%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">5.2.3.</span> <span class="toc-text">9.2.3. 验证不具备原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-4-volatile%E5%8E%9F%E7%90%86"><span class="toc-number">5.2.4.</span> <span class="toc-text">9.2.4. volatile原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-5-Happen-Before%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">5.2.5.</span> <span class="toc-text">9.2.5. Happen-Before（了解）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-CAS"><span class="toc-number">5.3.</span> <span class="toc-text">9.3. CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-1-%E5%9F%BA%E6%9C%AC%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"><span class="toc-number">5.3.1.</span> <span class="toc-text">9.3.1. 基本代码演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-2-%E9%AA%8C%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">5.3.2.</span> <span class="toc-text">9.3.2. 验证原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-3-%E7%BC%BA%E7%82%B9"><span class="toc-number">5.3.3.</span> <span class="toc-text">9.3.3. 缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-4-%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%BA%94%E7%94%A8"><span class="toc-number">5.3.4.</span> <span class="toc-text">9.3.4 原子类应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ABA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-number">5.3.4.1.</span> <span class="toc-text">ABA问题解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E6%90%93%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">5.3.4.2.</span> <span class="toc-text">手搓自旋锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-5-LongAdder%E6%BA%90%E7%A0%81"><span class="toc-number">5.3.5.</span> <span class="toc-text">9.3.5 LongAdder源码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%83%AD%E7%82%B9%E5%88%86%E6%95%A3"><span class="toc-number">5.3.5.1.</span> <span class="toc-text">热点分散</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%88%B6%E7%B1%BBStriped64-%E9%83%A8%E5%88%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">5.3.5.2.</span> <span class="toc-text">父类Striped64 部分成员变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-AQS"><span class="toc-number">5.4.</span> <span class="toc-text">9.4. AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-1-%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84"><span class="toc-number">5.4.1.</span> <span class="toc-text">9.4.1. 框架结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-2-%E5%9F%BA%E4%BA%8EAQS%E5%AE%9E%E7%8E%B0%E9%94%81%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-number">5.4.2.</span> <span class="toc-text">9.4.2. 基于AQS实现锁的思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-3-%E5%9F%BA%E4%BA%8EAQS%E5%AE%9E%E7%8E%B0%E7%8B%AC%E5%8D%A0%E9%94%81"><span class="toc-number">5.4.3.</span> <span class="toc-text">9.4.3. 基于AQS实现独占锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-4-ReentrantLock%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">5.4.4.</span> <span class="toc-text">9.4.4. ReentrantLock底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-4-1-Sync%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">5.4.4.1.</span> <span class="toc-text">9.4.4.1. Sync抽象类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-4-2-NonfairSync"><span class="toc-number">5.4.4.2.</span> <span class="toc-text">9.4.4.2. NonfairSync</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-4-3-FairSync"><span class="toc-number">5.4.4.3.</span> <span class="toc-text">9.4.4.3. FairSync</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-%E5%90%84%E7%A7%8D%E9%94%81"><span class="toc-number">5.5.</span> <span class="toc-text">9.5. 各种锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">10. ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">6.1.</span> <span class="toc-text">内存泄漏</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">12.并发集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">4. 并发容器类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E9%87%8D%E7%8E%B0%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%9AList"><span class="toc-number">8.1.</span> <span class="toc-text">4.1. 重现线程不安全：List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-CopyOnWrite%E5%AE%B9%E5%99%A8"><span class="toc-number">8.2.</span> <span class="toc-text">4.2. CopyOnWrite容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E6%89%A9%E5%B1%95%E7%B1%BB%E6%AF%94%EF%BC%9ASet%E5%92%8CMap"><span class="toc-number">8.3.</span> <span class="toc-text">4.3. 扩展类比：Set和Map</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">5. JUC强大的辅助类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-CountDownLatch"><span class="toc-number">9.1.</span> <span class="toc-text">5.1. CountDownLatch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-CyclicBarrier"><span class="toc-number">9.2.</span> <span class="toc-text">5.2. CyclicBarrier</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-Semaphore"><span class="toc-number">9.3.</span> <span class="toc-text">5.3. Semaphore</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">6. Callable接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-Callable%E5%92%8CRunable%E5%AF%B9%E6%AF%94"><span class="toc-number">10.1.</span> <span class="toc-text">6.1. Callable和Runable对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-Callable%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">10.2.</span> <span class="toc-text">6.2. Callable的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">10.3.</span> <span class="toc-text">6.3. 面试题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">7. 阻塞队列（BlockingQueue）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E4%BB%80%E4%B9%88%E6%98%AFBlockingQueue"><span class="toc-number">11.1.</span> <span class="toc-text">7.1. 什么是BlockingQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E8%AE%A4%E8%AF%86BlockingQueue"><span class="toc-number">11.2.</span> <span class="toc-text">7.2. 认识BlockingQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"><span class="toc-number">11.3.</span> <span class="toc-text">7.3. 代码演示</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By pengchang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://npm.elemecdn.com/hexo-butterfly-clock/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_injector_config();
  }
  </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://npm.elemecdn.com/hexo-butterfly-clock/lib/clock.min.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>